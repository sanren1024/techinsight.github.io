<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin——object（单例，伴生对象，内部类）]]></title>
    <url>%2F2018%2F06%2F20%2Fkotlin%2Fkotlin-in-action-object%2F</url>
    <content type="text"><![CDATA[在我的前一篇文章设计模式之单例模式中Kotlin实现中，有涉及到Kotlin中的伴生对象和属性委托的概念，这篇文章先来说说object（包括伴生对象）。 object关键字“object”，这个关键字与Java中的Object类不同，Kotlin中object关键字用以修饰类，在声明类的同时创建一个实例（即该类的一个对象）。可以理解成Java中的静态单例。 object关键字使用的几种不同的场景： 用以声明一个单例类; 伴生对象（可以持有工厂方法和其他与这个类相关，但在调用时不依赖于容器类的方法。他们的成员可以通过容器类的类名来访问即相当与Java中的静态成员形式）; 对象表达式（Java的匿名内部类）; 单例先来看object关键字修饰下的类的形式。 1object Factory 这是最简单的单例声明方法。为了更方便的了解这是单例，完整的demo代码来看下。 12345678object Factory &#123; val name: String = "object single"&#125;fun main(args: Array&lt;String&gt;) &#123; val factorySingle : Factory = Factory println(factorySingle.name)&#125; 在object类中定义一个name成员，然后在执行入口函数main()中引用这个单例，并且打印其成员name，实际的执行结果就是在控制台打印“object single”. 1234...object singleProcess finished with exit code 0 在函数main()中可以看到，引用创建时，等号右则直接是类名。Kotlin中使用object关键字修饰的类将一个类声明及该类的唯一实例创建结合在一起，这个功能也叫对象声明。 伴生对象再来说本篇文章的重点，即伴生对象。伴生对象从功能上的另外一个描述：它是工厂方法和静态成员的地盘。 与Java做一个比较，Kotlin本身是不支持static关键字的，即static关键字并不是Kotlin语言的一部分。作为替代方案，Kotlin提供了包级别函数（可以在大多数情况下替代Java的静态方法）和对象声明（大多数情况下替代Java的静态方法及静态成员），多数情况下，还是推荐使用顶层函数。 重点来了，标题是伴生对象，那么怎么来声明呢 ？ 在类中定义一个用特殊关键字标记的对象：companion。companion修饰的对象，使得外部可以直接通过companion容器类来访问这个对象（companion object）的属性和方法，就像Java中对静态方法和静态成员的访问形式，不需要再通过具体实例来访问。 下来看下Factory类的另外一个写法，并同样打印Factory成员name的值。 12345678910class Factory &#123; companion object &#123; const val name: String = "object single" &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val factory : Factory = Factory() println(Factory.name)&#125; 可以看到Factory对象创建依然是普通类对象的创建方式，而对name成员的访问的形式使用的是类名. 方式访问，而不是具体实例factory.name方式访问。 在标题开始，写到伴生对象的另外一种描述是：工厂方法和静态成员的地盘。静态成员的地盘这个描述相信通过上述的示例已经可以看出一二。 下来看看工厂方法是如何来表现的呢？创建一个User对象，根据不同的参数来获取User属性name。学习过Java的程序员首先想到的只怕是通过不同的构造方法，传入不同参数类型来实现。相应的Kotlin中也可以采用此种方式去实现。 12345678910111213141516class User &#123; val name: String constructor(name: String) &#123; this.name = name &#125; constructor(id: Int) &#123; this.name = getNameBy(id) &#125; private fun getNameBy(id: Int): String &#123; // ... return ".." &#125;&#125; 可以使用相同逻辑，但使用工厂方法来实现。 12345678910111213141516class User private constructor(val name: String) &#123; companion object &#123; fun createUserByName(name: String): User &#123; return User(name) &#125; fun createUserById(id: Int): User &#123; return User(getNameBy(id)) &#125; private fun getNameBy(id: Int): String &#123; // ... return ".." &#125; &#125;&#125; 工厂方法非常有用，它可以返回声明这个方法的类的子类。但如果需要在后期扩展相关的类，那么使用多个构造方法将是更好的选择，因为伴生对象成员在子类中是不可以被重写的。 做为普通对象的伴生对象伴生对象是一个类声明中定义的普通对象。它同样有名字，可以继承类，实现接口及扩展函数和属性。拿上述的User的伴生对象为例，为其定义一个名字。 12345678910111213141516171819202122class User private constructor(val name: String) &#123; companion object Factory &#123; fun createUserByName(name: String): User &#123; return User(name) &#125; fun createUserById(id: Int): User &#123; return User(getNameBy(id)) &#125; private fun getNameBy(id: Int): String &#123; // ... return ".." &#125; &#125;&#125;fun main(args: Array&lt;String&gt;) &#123; val user: User = User.Factory.createUserById(36) val user1: User = User.Factory.createUserByName("OK") val user2: User = User.createUserById(54)&#125; 代码中可以看到，可以通过User.Factory.xxx方式来调用方法，同时也可以直接使用User.xxx方式调用方法。因为companion修改的类随即就拥有了使其外部直接使用类名来访问伴生对象的成员，因此多数情况下，不需要关心伴生对象的名称。 伴生对象实现接口伴生对象跟其他对象声明一样，可以实现接口。其调用方式就是直接使用容器类来调用接口实现，就像容器类实现了相关接口一样。 12345678910111213interface JSONFactory&lt;T&gt; &#123; fun loadFromJson(json: String): T&#125;class User private constructor(val name: String) &#123; companion object Factory: JSONFactory&lt;User&gt; &#123; override fun loadFromJson(json: String): User &#123; // ... return User("..") &#125; // ... &#125;&#125; 在调用的时候，可以直接使用User.loadFromJson(json)方式来调用，就像是User实现了JSONFactory接口一样。 对象表达式对象表达式就功能来说就是改变写法的匿名内部类。这种用法取代Java的匿名内部类的写法。熟悉Android的同志肯定了解UI事件监听写法。 12345view.setOnClickListener( object: OnClickListener &#123; // TODO &#125;); 这里object关键字后冒号以及接口名的组成方式即是Kotlin的对象表达式。对象表达式声明了一个类的同时创建了该来的一个实例。 与Java的匿名内部类只能扩展一个类或实现一个接口不同，Kotlin中匿名对象可以实现多个接口或者不实现接口。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之单例模式]]></title>
    <url>%2F2018%2F06%2F20%2Fdesignpattern%2Fdesign-patterns-singleton%2F</url>
    <content type="text"><![CDATA[单例模式应该是所有设计模式中最有名的设计模式了，原理简单：一个类型的实例在全局中只有一个对象，要调用这个实例的方法必须经由这个单例来完成。 最简单的Java实现方式: 1234567public class Singleton &#123; private static final Singleton INSTANCE = new Singleton(); private Singleton() &#123;&#125; public static Singleton getInstance() &#123; return INSTANCE; &#125; &#125; 对应Kotlin实现： 1object Singleton 这里是最简单的实现方式，但对于不想一开始就创建对象，即延迟加载（仅在第一次使用它时才初始化）。 123456789101112public class Singleton &#123; private static Singleton INSTANCE; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; return INSTANCE; &#125; &#125; 对应Kotlin实现： 12345class Singleton private constructor() &#123; companion object &#123; val INSTANCE: Singleton by lazy &#123; Singleton() &#125; &#125; &#125; 为什么要延迟初始化呢？？在《Java设计模式》(Steven John Metsker, William C. Wake)一书中这样给出答案： 静态初始化时，没有足够信息对单例对象进行初始化。如工厂单例需要真正的工程类型才能建立起通信通道; 延迟加载也和资源获取有关，如数据库连接，尤其是在一个特定的会话中，它包含的应用程序并不需要该单例对象时。 换言之，采用延迟加载一般场景下均可以采用，而在某些场景下需要知道具体类型信息后才能创建对应对象时则必须采用延迟加载。而饿汉式加载方式在普通场景下均可以使用。 单例和多线程要在一个有多线程需求的项目中使用单例模式则需要小心，很可能因为线程运行调用流程造成系统死锁或者其他混乱情况。假设有线程A跟线程B，同时需要访问单例Singleton（以上述懒汉单例为例）对象来进行某项活动，获取Singleton对象并执行某些行为。 12345678910111213public class Singleton &#123; private static Singleton INSTANCE; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; //.... return INSTANCE; &#125; &#125; 当线程A调用getInstance()并执行到if语句判断INSTANCE == null时，线程B也执行到此处，而事前并为针对此种情况添加访问锁，最终出现两个线程初始化同一个实例的情况。这时就需要添加锁机制来进行排他性执行，即当线程A调用方法getInstance()进行INSTANCE == null判断并可能实例化时，线程B进行等待，待线程A执行完毕后，释放锁，线程B再进行执行。 123456789101112131415public class Singleton &#123; private static final Object LOCK = new Object(); // LOCK = Singleton.class private static Singleton INSTANCE; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; synchronized (LOCK) &#123; if (INSTANCE == null) &#123; INSTANCE = new Singleton(); &#125; return INSTANCE; &#125; &#125;&#125; 对应的Kotlin实现： 12345class Singleton private constructor() &#123; companion object &#123; val INSTANCE: Singleton by lazy(LazyThreadSafetyMode.SYNCHRONIZED) &#123; Singleton() &#125; &#125;&#125; 这样添加了锁之后，当线程A执行方法getIntance()时，线程B就发现方法被锁了，从而等待执行，当线程A执行完毕并释放锁LOCK时，线程才开始执行getInstance()方法。 PS：延迟加载和同步锁即是单例模式的双重检查。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基础]]></title>
    <url>%2F2018%2F04%2F14%2Fkotlin%2Fkotlin-in-action-basics%2F</url>
    <content type="text"><![CDATA[Kotlin是一门静态类型语言且支持类型推导，允许维护正确性与性能的同时保持源码简洁。Kotlin支持面向对象和函数式两种编码风格，通过头等函数使更高级别的抽象成为可能，通过支持不可变值简化了测试和多线程开发。 Kotlin在服务器应用程序上也可以运行的很好，全面支持所有现存的Java框架。且Kotlin在Android上也可以工作，这得益于对Android API特殊的编译器支持以及丰富的库，为常见Android开发任务提供了Kotlin友好的函数。 它是免费和开源的，全面支持主流的IDE和构建系统。 本文内容：- 声明函数、变量、类、枚举以及属性- Kotlin中的控制结构- 智能转换- 抛出和异常处理 函数和变量函数首先看著名的hello world代码：123fun main(args: Array&lt;String&gt;) &#123; println("Hello World!")&#125; 这里给出了最基本的函数声明。 关键字fun用来声明一个函数。 参数类型写在变量之后。 Kotlin中每行代码结尾省略了分号。 再看一段函数声明：123fun compare(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b&#125; 在函数后边紧跟着函数返回类型，返回类型与函数声明之间用冒号分隔。 这里可以看到，if是一个表达式，而不是语句。语句与表达式的区别在于，表达式有值，语句并没有自己的值。在Kotlin中，除了循环（for, while, do..while）之外，大多数控制结构都是表达式。 提到函数，Kotlin中有一个表达式函数体的概念。 即函数体由单个表达式构成，可以用这个表达式作为完整的函数体，并去掉花括号和return语句。1fun compare(a: Int, b: Int): Int = if (a &gt; b) a else b 如果函数体在花括号中，这个函数是代码块体函数。 这里的compare函数还可以进一步简化，如下:1fun compare(a: Int, b: Int) = if (a &gt; b) a else b 即省略函数返回类型。那么会有疑问，为什么函数可以不要返回值类型？？作为一门静态语言，Kotlin应该要求所有的表达式应该在编译期间就有类型？事实上，Kotlin的每个变量和表达式独有类型，每个函数也都有返回类型。而对表达式函数体来说，编译器会分析作为函数体的表达式，并把它的类型作为函数的返回类型，即使没有显示地显示出来。这种分析叫类型推导。 变量了解Java的开发人员度知道，java在声明变量的时候会以类型开始。Kotlin中不需要这么麻烦，许多的变量声明的类型都可以省略。Kotlin中变量的声明是以关键字开始，变量名称最后加上类型（不加也可以）。 例如：12val number = 3val literal = "Hello World!" 可以看到这里的变量声明也没有加上类型声明，为何？这个原理跟表达式函数体一样，编译器会分析表达式值得类型，并把它的类型作为变量的类型。 但是不是所有的情况都可以省略变量类型，最直接的情况就是在没有对变量进行初始化的情况下，这个时候就需要在声明中加上变量的类型。 例如：12val numbernumber = 4 上边这样的声明方式，编译器会提示错误1Error: This vairable must either have a type annotation or be initialized. 这就说明了Kotlin中变量声明要么一开始就进行初始化而不加类型，要么不进行初始化但必须要加上变量类型。 因为如果不能提供可以赋给这个变量的值得信息，编译器就无法推导出它的类型，进而无法知道变量的类型。 Kotlin中的变量可分为可变变量和不可变量： val —— 不可变引用。val声明的变量赋值之后不可更改。与Java的final对应。 var —— 可变引用。var声明的变量的值可变。与Java中的一般的变量相当。 默认情况下，Kotlin中尽可能的将变量声明为val，只在需要的时候换成var。 另外，声明了val变量的代码块中，如果编译器分析后可以确保变量在整个执行过程中只会有唯一一次的赋值行为，那么也是可以的。123456val average: Intif (isMain) &#123; average = 8&#125; else &#123; average = 5&#125; 另外还有与Java类似的是，val引用本身是不可变的，但其指向的对象是可以改变的。12val programs = arrayListOf("Java")programs.add("Kotlin") val关键字目前就是这么些注意的内容，再来谈谈var。var声明的变量虽然是可变的，但是变量的类型是不可变的。 编译器只会根据变量初始化器来推导变量的类型，在确认类型之后不会再考虑后续赋值操作。12var count = 1count = "hello" 这段变量声明是不合法的，变量count的类型在初始化为1的时候已经确认了是Int类型，再去给其赋值为String类型，这是编译器回给出错误提示。1Type mismatch: Infer type is String but Int was expected 顺便提下，Kotlin中的字符串格式化：字符串模板先看一段简单的代码1234fun main(args: Array&lt;String&gt;) &#123; val language = if (args.size &gt; 0) args[0] else "Kotlin" println("Hello $language!")&#125; 这段代码中可以看到，变量language前边有$符号，这种写法就是需要说的Kotlin中的新特性，字符串模板。字符串模板的作用即是可以在程序的字符串中引用变量。这种表达写法相当于在Java中使用StringBuilder方式的append()方法，或者是Java中”Hello “ + language + “!”写法。但是相比之下，Kotlin的写法可读性更好。 字符串模板可以有更加复杂的表达方式——${表达式语句}可以将上述代码进行一定的修改123fun main(args: Array&lt;String&gt;) &#123; println("Hello $&#123;if (args.size &gt; 0) args[0] else "Kotlin"&#125;!")&#125; 这样的写法也是对的，其中可以看到花括号中又有一对引号。在Kotlin中可以在双引号中嵌套双引号，但需要在表达式内部（即在花括号内）。 类和属性但凡了解Java的开发人员对这两个概念不会陌生。下来看看Kotlin中如何来声明类的。先看看Java中的声明方式。1234567891011public class Person &#123; private final String name; public Person(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125; 这是最典型的的JavaBean类。再看看对应的Kotlin是怎么声明的。1class Person(val name: String) 使用Kotlin声明这样一个类，就只有一行。Kotlin中这种类（只有数据没有其他代码）被称为值对象。同样也应该注意到了，Java声明中的public访问修饰符到Kotlin对应的声明中就不见了，这是因为Kotlin中public是默认的可见性。 属性我们知道Java中的属性是由字段及其对应的getter，setter方法组成。Kotlin中属性是头等的语言特性，其完全地取代了字段和对应的访问器。 在Kotlin中声明一个属性跟声明一个变量使用同样的关键字val和var。声明val的属性是只读的，var属性是可变的。1class Person(val name: Strinig, var isMerried: Boolean) Kotlin中在声明一个属性的时候，同时也就声明了访问器。Kotlin中访问器的默认实现很简单，创建一个存储值得字段，以及getter和setter方法。同样可以自定义访问器，及自己的getter和setter方法。 自定义访问器先看看如何来判断一个矩形是否是正方形的程序。 123456class Rectangle(val height: Int, val width: Int) &#123; val isSquare: Boolean get() &#123; return (height == width) &#125;&#125; 目录和包与Java一样，Kotlin源码布局同样包含了包的概念。每个Kotlin文件都以一个package语句开始，接着是import语句（Kotlin中import的可以是类，也可以是函数）。 Kotlin中有一点与Java不同的是：Kotlin文件的包层级结构可以不遵循目录结构。及Kotlin文件中package语句的包声明与程序的工程目录结构可以不一致。且多个类可以放置在一个Kotlin文件中，文件名任意。 但在具体实现过程中，遵循包层级结构与目录层级结构一直是比较好的实践，尤其是在程序中兼有Java和Kotlin程序文件。 枚举和“when”枚举Kotlin中的枚举声明需要使用两个关键字：enum class。这也是Kotlin中极少数比Java声明关键字多的地方。 Kotlin中的enum是一个软关键字。即enum只有出现在class之前才有意义，平时使用可以当做一般名称使用。 枚举类不只是值得列表，可以为其声明方法。12345enum class Color(val r: Int, val g: Int, val b: Int) &#123; RED(255, 0, 0), GREEN(0, 255, 0), BLUE(0, 0, 255); fun rgb = (r * 256 + g) * 256 + b&#125; 这里也有唯一一个Kotlin中使用分号的地方。 when]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter(四) 搭建布局]]></title>
    <url>%2F2018%2F04%2F11%2Fflutter%2Fflutter-building-layouts%2F</url>
    <content type="text"><![CDATA[你将学习:&nbsp;&nbsp; - Flutter布局机制如何工作&nbsp;&nbsp; - 如何竖直或横向展示组件&nbsp;&nbsp; - 如何搭建Flutter布局 这篇文章说明Flutter搭建布局。我们将学习搭建布局，做种效果如下截图： 这篇引导退一步来解释Flutter进行布局的方式，以及展示如何在屏幕上放置一个单独的组件。在学习完如何横向或竖向展示组件之后，我们会再看到些常用的布局组件。 搭建布局 Step 0：创建 Step 1：图解布局 Step 2：实现标题行 Step 3：实现按钮行 Step 4：实现文本区域 Step 5：实现图片区域 Step 6：整合 Flutter布局方法 布局一个组件 横向及竖向布局多个组件 组件对齐方式 调整组件大小 缩紧组件 嵌套行与列 常用布局组件 标准组件 Material组件 资源 搭建布局若你想理解“big picture”的布局原理，那么需要学习Flutter布局方法。 Step 0：创建首页获取代码： 确定已经设置好环境 创建基本Flutter工程 下来在工程中添加图片： 在工程根目录创建images目录 添加 lake.jpg 图片 更新 pubspec.yaml 文件，添加 assets 标签 Step 1：图解布局第一步是将布局分解成基本元素: 区分行与列。 布局是否包含一个网格？ 是否有层叠元素？ UI是否需要tabs？ 注意需要对齐，内边据或者边框的区域。 首先，识别更大的元素。在这里，四个元素在同一列中：一个图片，两行和一个文本块。 接下来，图解每行。第一行，我们称其Title Section，有3个子组件：一列文本区域，一个星型图标，及一个数字。第一列子组件包含2行文本。且第一列占有较大空间，因此需要将两行文本放在Expanded组件中。 第二行，我们称其Button section，同样有3个子组件：由三列组成，且每列均由一个图标和文本组成。 在图解了布局之后，再从细节到整体来实现这个布局就容易了。为了让嵌套的代码看起来不那么混乱，我们将一些实现置于变量和函数中。 Step 2：实现Title Section首先需要在Title Section左侧创建一列。在Expanded组件中的Column组件使得当前列（column并非组件）可以覆盖真个Title section. 将Column组件的 crossAxisAlignment 属性设置为CrossAxisAlignment.start ，这样Column组件位于当前行的起始位置。 将第一行的文本组件放置于Container组件中以便添加Container内边据。第二个文本组件文字是灰色。 最后的2个组件包括一个红色星型图标和一个数字“41”的文本。将整个标题行（Title Section图解中的Row with 3 children）放置在一个Container组件中，并且设置Container组件32px的内边距。 Note: 如何代码实现有问题，可以依据Github上的lib/main.dart 来检查你的代码。 123456789101112131415161718192021222324252627282930313233343536373839class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; Widget titleSection = new Container( padding: const EdgeInsets.all(32.0), child: new Row( children: [ new Expanded( child: new Column( crossAxisAlignment: CrossAxisAlignment.start, children: [ new Container( padding: const EdgeInsets.only(bottom: 8.0), child: new Text( 'Oeschinen Lake Campground', style: new TextStyle( fontWeight: FontWeight.bold, ), ), ), new Text( 'Kandersteg, Switzerland', style: new TextStyle( color: Colors.grey[500], ), ), ], ), ), new Icon( Icons.star, color: Colors.red[500], ), new Text('41'), ], ), ); //...&#125; Tip: 粘贴代码到工程中时，代码缩进可能错乱。如果是在IntelliJ中，可以有单机选择Reformat with Dart Style。或者在命令行中使用dartfmt命令。Tip: 为体验更快开发过程，尝试使用Flutter的热加载功能。热加载使得在修改代码同时快速地在查看到修改后的效果，而不用重运行app。 Step 3：实现按钮行（Button Section）Button Section包含3列相同的布局——一个图标和一个文本。这行中3列均匀分布，并且文本和图标颜色是APP build()方法中设置的primary color。 12345678910111213class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; // title section implementation return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData( primarySwatch: Colors.blue, ), //...&#125; 由于创建每列的代码是相同的，最高效的办法就是创建一个嵌套函数，例如就定义为buildButtonColumn()，这个方法中创建包含一个图标和一个文本得组件，并且返回Column对象。 1234567891011121314151617181920212223242526272829class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; //... Column buildButtonColumn(IconData icon, String label) &#123; Color color = Theme.of(context).primaryColor; return new Column( mainAxisSize: MainAxisSize.min, mainAxisAlignment: MainAxisAlignment.center, children: [ new Icon(icon, color: color), new Container( margin: const EdgeInsets.only(top: 8.0), child: new Text( label, style: new TextStyle( fontSize: 12.0, fontWeight: FontWeight.w400, color: color, ), ), ), ], ); &#125; //...&#125; 这个创建方法中直接添加icon组件。将文本组件放于Container组件中来添加上边距，将icon与text分离开。 1234567891011121314151617class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; //... Widget buttonSection = new Container( child: new Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: [ buildButtonColumn(Icons.call, 'CALL'), buildButtonColumn(Icons.near_me, 'ROUTE'), buildButtonColumn(Icons.share, 'SHARE'), ], ), ); //...&#125; Step 4：实现多行文本（Text Section）由于文本太长，其实现我们赋值于一个变量。将文本放在Container中，四周边距设置32px。设置softwrap属性，这个属性表示当每行文本遇到句号或者逗号时是否需要换行。 12345678910111213141516class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; //... Widget textSection = new Container( padding: const EdgeInsets.all(32.0), child: new Text( '''Lake Oeschinen lies at the foot of the Blüemlisalp in the Bernese Alps. Situated 1,578 meters above sea level, it is one of the larger Alpine Lakes. A gondola ride from Kandersteg, followed by a half-hour walk through pastures and pine forest, leads you to the lake, which warms to 20 degrees Celsius in the summer. Activities enjoyed here include rowing, and riding the summer toboggan run. ''', softWrap: true, ), ); //...&#125; Step 5：实现头部图片（Image Section）目前只剩头部图片部分还未实现。这张图片基于Creative Commons协议在网上是可以获取到的（当然学习过程，可以自己比较随意的拿一张图片进行）。由于图片较大且网络加载慢，所以在Step 0步骤中已经inlude进来并且修改了pubspec.yml文件，可以直接在本地进行访问。 12345678910body: new ListView( children: [ new Image.asset( 'images/lake.jpg', height: 240.0, fit: BoxFit.cover, ), // ... ],) BoxFit.cover 告诉Framework图片需要尽可能的小但是需要充满显示部分。 Step 6：整合最后一步，将删除个步骤中定义的组件最终整合在一起。所有组件放置于ListView中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; Widget titleSection = new Container( padding: const EdgeInsets.all(32.0), child: new Row( children: &lt;Widget&gt;[ new Expanded( child: new Column( crossAxisAlignment: CrossAxisAlignment.start, children: &lt;Widget&gt;[ new Container( padding: new EdgeInsets.only(bottom: 8.0), child: new Text( 'Oeschinec lake Compground', style: new TextStyle(fontWeight: FontWeight.bold), ), ), new Text( 'Kandersteg, Switzerland', style: new TextStyle(color: Colors.grey[500]), ), ], )), new Icon( Icons.star, color: Colors.red[500], ), new Text('41') ], ), ); // button section Column buildButtonColumn(IconData icon, String label) &#123; Color color = Theme.of(context).primaryColor; return new Column( mainAxisAlignment: MainAxisAlignment.center, mainAxisSize: MainAxisSize.min, children: &lt;Widget&gt;[ new Icon(icon, color: color), new Container( margin: const EdgeInsets.only(top: 8.0), child: new Text( label, style: new TextStyle( color: color, fontSize: 12.0, fontWeight: FontWeight.w400, ), ), ), ], ); &#125; Widget buttonSection = new Container( child: new Row( mainAxisAlignment: MainAxisAlignment.spaceEvenly, children: &lt;Widget&gt;[ buildButtonColumn(Icons.call, 'CALL'), buildButtonColumn(Icons.near_me, 'ROUTE'), buildButtonColumn(Icons.share, 'SHARE'), ], ), ); Widget textSection = new Container( padding: const EdgeInsets.all(32.0), child: new Text( ''' Lake Oeschinen lies at the foot of the Blüemlisalp in the Bernese Alps. Situated 1,578 meters above sea level, it is one of the larger Alpine Lakes. A gondola ride from Kandersteg, followed by a half-hour walk through pastures and pine forest, leads you to the lake, which warms to 20 degrees Celsius in the summer. Activities enjoyed here include rowing, and riding the summer toboggan run. ''', softWrap: true, ), ); return new MaterialApp( title: 'Flutter Demo', theme: new ThemeData(primarySwatch: Colors.blue), home: new Scaffold( appBar: new AppBar( title: new Text('Top Lakes'), ), body: new ListView( children: &lt;Widget&gt;[ new Image.asset( 'images/lake.jpg', height: 240.0, fit: BoxFit.cover, ), titleSection, buttonSection, textSection, ], ), ), ); &#125;&#125;]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter(三) 入门：学习更多]]></title>
    <url>%2F2018%2F04%2F11%2Fflutter%2Fflutter-get-started-learn-more%2F</url>
    <content type="text"><![CDATA[学习更多有关Flutter的framework 构建布局(Building Layouts) 教程 交互(Add Interactivity) 教程 Flutter组件框架(Flutter Widget Framework) Android开发者使用Flutter(Flutter for Android Developers) 其他资源 Flutter详尽说明(Flutter Cookbook) Java转向Dart(From Java to Dart) 指引 Dart程序：学习更多Dart知识 学习愉快。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter(二) 创建第一个Flutter APP]]></title>
    <url>%2F2018%2F03%2F29%2Fflutter%2Fflutter-create-your-first-app%2F</url>
    <content type="text"><![CDATA[这一章主要是创建一个Flutter App。如果你熟悉面向对象编程，有基本的编程概念（变量，循环，条件判断等），那么你不必要具备原有的Dart和移动开发经验，就可以轻松地理解完成这章内容。 Step 1：创建第一个flutter app Step 2：使用外部包 Step 3：添加一个有状态的组件（Stateful widget） Step 4：创建无限滚动ListView Step 5：添加交互 Step 6：跳转到另一个屏 Step 7：利用主题改变UI 构造什么 你将为一家初创公司实现一个简单的移动app，主要功能是为这家公司推荐名字。用户可以选择或者取消名字，保存最好的名字。程序会一次性产生10个名字。在用户滚动时，新名字同时会产生出来。用户可以点击导航栏（appbar）的列表图标进入到一个新的列表页查看喜欢的名字。 最终的结果最后运行结果中可以看到。 你将会学到： Flutter app基本结构 查找并使用包来扩展功能 使用热加载加快开发周期 如何实现一个有状态组件（Stateful widget） 如何创建一个无限，懒加载列表 如何创建并路由到第二个屏幕 如何使用app主题修改外观 你将会使用：需要安装： Flutter SDKFlutter SDK包含了Flutter引擎，framework，组件，工具，和Dart SDK。这份代码实验需要v0.1.4或者更高版本。 Android Studio这次代码实验需要Android Studio。也可以在命令行。 需要IDE插件IDE上必须分别安装Flutter和Dart插件。 查看Flutter安装学习如何建立起你的Flutter环境 Step 1：创建Flutter App 创建第一个简单的，IDE提供模板的Flutter App，可以按照引导创建Flutter工程。我将工程名命名为flutter_app，这个按照个人习惯吧，只要名称合法就行。 在这节程序实验中，最多编辑的会是lib/main.dart，其中就是Dart代码。 Tips：当你粘贴代码到IDE中的时候，可能发生缩进不对齐的情况。你可以使用Flutter工具来解决这种问题： 1. Android Studio/IntelliJ IDEA：右单击Dart代码，选择Refactor code with dartfmt 2. VS Code：右单击选择 Format Document 3. Terminal：运行命令 flutter format filename。 替换模板的lib/main.dart移除原有工程中的模板代码lib/main.dart。输入如下代码，可以查看到UI中间显示的“Hello World”。 1234567891011121314151617181920import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123;truereturn new MaterialApp(true title : 'Welcome to Flutter',true home:new Scaffold(truetrueappBar:new AppBar(truetrue title:new Text('Welcome to Flutter'),truetrue),truetruebody:new Center(truetrue child:new Text('Hello World'),truetrue),true ),true); &#125;&#125; 运行app，可以看到如下执行效果 结果 这个例子创建了一个Material app。Material是在移动端和web端上的设计标准。Flutter提供了丰富的Material组件。 main()方法声明了胖箭头(=&gt;)符号表示法，这种写法表示了man()方法是一个单行函数，即函数体只有一行代码构成。 App继承StatelessWidget，这也使得App本身成为了一个组件。在Flutter中，几乎所有对象都被认为是一个组件，包含对齐方式，内边距和布局。 Material组件库中的Scaffold提供了App默认需要的appbar，title，和body属性，body属性包含了home screen的组件树结构。组件的子组件结构可以相当复杂。 组件的主要工作就是提供build()方法，描述如何展示自己及其他组件。 这个例子中组件结构有一个Center组件中包含一个Text子组件组成。Center组件将其内的组件结构置于屏幕中央。 Step 2：使用外部包 这一步中，你将使用开源包english_words。这个包中包含了几千个最常用的英文单词和一些实用方法。 你可以在pub.dartlang.org找到english_words包，同时还有其他的开源包。 文件pubspec.yaml管理者Flutter App的资源。在pubspec.yaml中，添加english_words（3.1.0或者更高）到依赖列表。如下代码中： 12345678910...dependencies: flutter:sdk:flutter # The following adds the Cupertino Icons font to your application. # Use with the CupertinoIcons class for iOS style icons. cupertino_icons:^0.1.0 english_words:^3.1.0 ... 原有模板文件中代码太多（包含注释），不全部展示出来。这里在depenencies下添加english_words包依赖。 在Android Studio编辑器中查看pubspec.yaml文件时，可以看到编辑器右上方有命令操作栏，点击Package get。这就是获取english_words包操作。你会在控制台命令行看到： 在lib/main.dart中，添加对english_words包的导入，如下显示的导入语句： 12import 'package:flutter/material.dart'; import 'package:english_words/english_words.dart'; 在你输入后，AS会因为你写的导入语句给出建议。表现在你输入的导入语句会变成灰色，这就是提示你导入的库还没有使用过。 使用english_words包来生成文本，而不再显示“Hello World”Tips：“Pascal case”(大驼峰规则)意思是在一个字符串中的每个单词，包括第一个单词，都是以大些字母开头。因此，“uppercamelcase”就是”UpperCamelCase”。 针对原有代码做出修改 12345678910111213141516171819202122import 'package:flutter/material.dart'; import 'package:english_words/english_words.dart'; void main() =&gt; runApp(new MyApp()); class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final wordPair = new WordPair.random(); true return new MaterialApp( true title:'Welcome to Flutter', truetruehome:new Scaffold( truetrue appBar:new AppBar( truetrue title:new Text('Welcome to Flutter'), truetrue ), truetruebody:new Center( truetrue child:new Text(wordPair.asPascalCase), truetrue ), truetrue), true ); &#125; &#125; 如果App正在运行，使用热加载按钮更新app。每次点击热加载按钮，或者进行保存时，你应该都能在运行的app上看到随机选取的不同的单词对。这是因为单词对是在build()方法中产生，build()方法每次在MaterialApp需要渲染或者在Flutter Inspector中打开Platform时被执行。 Step 3：添加有状态组件 无状态组件(Stateless widget)是不可变的，意味着他们的属性无法改变——所有值是final的。 有状态组件(Stateful widget)维持一个状态值，此状态值会根据组件生命周期而有所改变。实现一个有Stateful widget需要至少两个类： StatefulWidget类用以创建实例； State类。 StatefulWidget组件本身是不可变的，但是State类在整个组件声明周期过程中是始终存在的。 在这步中，你将会添加一个stateful widget，RandomWords以及创建对应的状态State类，RandomWordsState。State类实际上为组件保留着喜欢的单词对。 在main.dart文件中添加RandomWords组件。这个类可以定义在文件内任意位置，但是我将其定义在文件末尾。 12345class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState(); &#125; 添加RandomWordsState类。大部分的app功能代码都会在这个类中。这个类同时保存用户滚动列表过程中产生的所有单词对，以及用户添加喜欢或者移除的单词对。下面添加对基本的了定义，来保证类文件编译通过 12class RandomWordsState extends State&lt;RandomWords&gt; &#123;&#125; 添加State类之后，IDE会提示缺少一个build()方法。下一步，需要将产生单词对的代码移至这个build()方法中。 在RandomWordsState的build()方法中添加代码，整个文件看起来像这样 1234567891011121314151617181920212223242526272829303132333435import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title:'Welcome to Flutter', home:new Scaffold( appBar:new AppBar( title:new Text('Welcome to Flutter'), ), body:new Center( child:new RandomWords(), ), ), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125;class RandomWordsState extends State&lt;RandomWords&gt; &#123; @override Widget build(BuildContext context) &#123; final wordPair = new WordPair.random(); return new Text(wordPair.asPascalCase); &#125;&#125; 重启App运行。目前修改的代码在运行起来之后，效果与之前的一样，只是将无状态组件换成了有状态组件。 Step 4：创建无限滚动列表 在这步中，你将扩展RandomWordsState类来展示一个列表。列表随着用户的滚动无限增粘。ListView的builder工厂方法可以按需要进行懒加载。 在RandomWordsState中添加 suggestions 列表变量保存生成的候选单词对。变量以 (\) 开头 ——在Dart中，下划线开头的变量强调私有 同时添加比变量 biggerFont 改变字体大小。 123456class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); ...&#125; 在RandomWordsState类中添加 _buildSuggestions()方法。这个类主要功能就是产生需要展示的单词对列表。 Listview提供了builder属性itemBuilder 用以产生item及匿名函数的回调。BuildContext和行的迭代器索引 i ，这两个参数被传到ListView的buil()方法。迭代器索引从0开始增长，每次方法调用产生一个单词对的时候就会增长。这就使得列表在用户滚动时无限增长。增加代码后，整个类看起来就是 12345678910111213141516171819202122232425262728293031323334353637class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); final _saved = new Set&lt;WordPair&gt;(); ..... Widget _buildSuggestions() &#123; return new ListView.builder( padding:const EdgeInsets.all(16.0), // The itemBuilder callback is called once per suggested word pairing, // and places each suggestion into a ListTile row. // For even rows, the function adds a ListTile row for the word pairing. // For odd rows, the function adds a Divider widget to visually // separate the entries. Note that the divider may be difficult // to see on smaller devices. itemBuilder:(context, i) &#123; // Add a one-pixel-high divider widget before each row in theListView. if (i.isOdd) return new Divider(); // The syntax "i ~/ 2" divides i by 2 and returns an integer result. // For example:1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2. // This calculates the actual number of word pairings in the ListView, // minus the divider widgets. final index = i ~/ 2; // If you've reached the end of the available word pairings... if (index &gt;= _suggestions.length) &#123; // ...then generate 10 more and add them to the suggestions list. _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125; ); &#125;&#125; 在 _buildSuggestions()方法中调用了 _buildRow()方法。这个函数作用是在ListTile组件中显示新的单词对。ListTile组件可以让你的每行看起来更加具有渲染力。 在RandomWordsState中添加 _buildRow()方法 1234567891011class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... Widget _buildRow(WordPair pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;&#125; 最后来更新RandomWordsState入口函数build()。整体文件最终代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title:'Welcome to Flutter', home:new RandomWords(), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125;class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); @override Widget build(BuildContext context) &#123; return new Scaffold ( appBar:new AppBar( title:new Text('Startup Name Generator'), ), body:_buildSuggestions(), ); &#125; Widget _buildSuggestions() &#123; return new ListView.builder( padding:const EdgeInsets.all(16.0), // The itemBuilder callback is called once per suggested word pairing, // and places each suggestion into a ListTile row. // For even rows, the function adds a ListTile row for the word pairing. // For odd rows, the function adds a Divider widget to visually // separate the entries. Note that the divider may be difficult // to see on smaller devices. itemBuilder:(context, i) &#123; // Add a one-pixel-high divider widget before each row in theListView. if (i.isOdd) return new Divider(); // The syntax "i ~/ 2" divides i by 2 and returns an integer result. // For example:1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2. // This calculates the actual number of word pairings in the ListView, // minus the divider widgets. final index = i ~/ 2; // If you've reached the end of the available word pairings... if (index &gt;= _suggestions.length) &#123; // ...then generate 10 more and add them to the suggestions list. _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125; ); &#125; Widget _buildRow(WordPair pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;&#125; 最终重新启动App运行。 Step 5：添加交互 这步中，你讲为每行item添加一个可点击的心形图标，在用户点击item时，对应的单词对（word pair）会被添加到收藏或者被移除。 在RandomWordsState类中添加一个 _saved 集合（Set）变量。这个集合保存了用户喜欢并收藏的单词对。之所以使用集合是因为集合可以保证其中没有重复的单词对。 12345678class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); final _saved = new Set&lt;WordPair&gt;(); ...&#125; 在函数_buildRow()中，添加变量alreadySaved来检查用户点击的wordPair是否已经保存。 1234Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); ...&#125; 同样还需要在函数_buildRow()中，需要在ListTiles中添加心形图标来表示收藏状态。后边，你将会为次添加收藏取消功能的交互。 12345678910111213Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), trailing:new Icon( alreadySaved ? Icons.favorite :Icons.favorite_border, color:alreadySaved ? Colors.red :null, ), );&#125; 重启App。就将看到列表中每行右侧添加了一个心形图标。 为每行添加可点击功能。即若被点击的item对应的单词对已经被收藏了，那么就会被取消收藏，反之就添加到收藏。当一个tile被点击，函数调用setState()通知framework状态发生改变。添加的代码如下，在_buildRow()方法中进行添加 12345678910111213141516171819202122Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), trailing:new Icon( alreadySaved ? Icons.favorite :Icons.favorite_border, color:alreadySaved ? Colors.red :null, ), onTap:() &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, );&#125; Tips：在Flutter的响应框架中，调用setState()方法会出发调用State类的bulid()方法，这就导致了更新UI操作。 重运行App。你应该可以通过点击来添加或者取消收藏。注意的一点是，在点击的时候可以看到一个放射性的点击效果，这是Material风格所致。如果有Android开发经验的程序员就会知道。 Step 6：导向新的一屏 在这步中，你将添加一个新屏幕（在Flutter叫做route）来展示你的收藏。你将学习如何在home route和新route之间进行交互。 在Flutter中，导航器(Navigator)管理着所有app route的一个栈。向栈内push一个route就表示这将展示新的一屏。pop出栈表示向前显示一屏。 在RandomWordsState类的build方法中，在AppBar上添加一个列表图标。当用户点击列表icon，包含收藏数据的新的route就会被推送的栈中，并且展示新的一屏。Tips：某些组件属性只包含一个子组件(child)，而某些属性（像action）拥有一组子组件(children)，这种方式通过方括号表示([])。 在方法中添加icon和对应的action: 12345678910111213141516171819202122....class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); final _saved = new Set&lt;WordPair&gt;(); @override Widget build(BuildContext context) &#123; return new Scaffold ( appBar:new AppBar( title:new Text('Startup Name Generator'), actions:&lt;Widget&gt;[ new IconButton(icon:new Icon(Icons.list), onPressed:_pushSaved), ], ), body:_buildSuggestions(), ); &#125; ....&#125; 上边的代码中同时定义了press回到，因此同时需要定义方法 123456class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... void _pushSaved() &#123; &#125;&#125; ... 此处方法中并未添加任何代码。 在用户点击appbar上的列表icon。系统构建一个route并且push到Navigator的栈中。这种操作改变了屏幕的显示，显示了新的route。这个新页面的内容在MaterialPageRoute的builder的匿名函数中构建。 添加调用Navigator.push，将route推送的Navigator栈中。 123456789...class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... void _pushSaved() &#123; Navigator.of(context).push( ); &#125; &#125;... 添加MaterialPageRoute和对应的builder。现在，可以在push方法中添加对应的代码，展示收藏的单词对列表。使用toList()方法转换将最终的数据赋值给divided 变量，使其拥有最终数据。 12345678910111213141516171819202122void _pushSaved() &#123; Navigator.of(context).push(new MaterialPageRoute( builder:(context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context:context, tiles:tiles, ) .toList(); &#125;, ),); &#125; builder属性返回一个Scaffold（包含了新route的appbar）组件命名“Saved Suggestions”。新的route由ListTile组件组成的列表组成，ListTiles之间有分隔符分割。 这样整体的代码如下 12345678910111213141516171819202122232425262728293031void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute( builder:(context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context:context, tiles:tiles, ) .toList(); return new Scaffold( appBar:new AppBar( title:new Text('Saved Suggestions'), ), body:new ListView(children:divided), ); &#125;, ), );&#125; 重运行App。收藏几个单词对，然后点击appbar上的列表icon，将会出现新的一屏来展示收藏的单词对。注意新出现的一页上默认会又给返回按钮，这个Navigator默认添加的。这样你不用特意为返回另外写程序来执行Navigator.pop来返回。点击返回按钮就可以返回到之前的页面。整体代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title:'Welcome to Flutter', home:new RandomWords(), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125;class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); final _saved = new Set&lt;WordPair&gt;(); @override Widget build(BuildContext context) &#123; return new Scaffold( appBar:new AppBar( title:new Text('Startup Name Generator'), actions:&lt;Widget&gt;[ new IconButton(icon:new Icon(Icons.list), onPressed:_pushSaved), ], ), body:_buildSuggestions(), ); &#125; void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute( builder:(context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context:context, tiles:tiles, ) .toList(); return new Scaffold( appBar:new AppBar( title:new Text('Saved Suggestions'), ), body:new ListView(children:divided), ); &#125;, ), ); &#125; Widget _buildSuggestions() &#123; return new ListView.builder( padding:const EdgeInsets.all(16.0), // The itemBuilder callback is called once per suggested word pairing, // and places each suggestion into a ListTile row. // For even rows, the function adds a ListTile row for the word pairing. // For odd rows, the function adds a Divider widget to visually // separate the entries. Note that the divider may be difficult // to see on smaller devices. itemBuilder:(context, i) &#123; // Add a one-pixel-high divider widget before each row in theListView. if (i.isOdd) return new Divider(); // The syntax "i ~/ 2" divides i by 2 and returns an integer result. // For example:1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2. // This calculates the actual number of word pairings in the ListView, // minus the divider widgets. final index = i ~/ 2; // If you've reached the end of the available word pairings... if (index &gt;= _suggestions.length) &#123; // ...then generate 10 more and add them to the suggestions list. _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125;); &#125; Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), trailing:new Icon( alreadySaved ? Icons.favorite :Icons.favorite_border, color:alreadySaved ? Colors.red :null, ), onTap:() &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, ); &#125;&#125; Step 7：使用主题修改UI 这是最后一步，你将使用theme。主题（theme）主要控制app看起来外表如何。可以使用默认的主题，从文章开始到目前使用的一直是默认的主题。主题不依赖与物理设备或者模拟器。你也可以自定义自己的主题来突显你自己的品牌。 通过ThemeData类你可以很简单的修改app的主题。像下边一样修改下代码，就可以改变页面的主标题主题 123456789101112class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title:'Startup Name Generator', theme:new ThemeData( primaryColor:Colors.white, ), home:new RandomWords(), ); &#125;&#125; 重运行App看看效果。需要注意的是整个的页面背景是白色的，甚至appbar也是白色的。 好了，这章的内容就是这些了。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter(一) 环境准备]]></title>
    <url>%2F2018%2F03%2F15%2Fflutter%2Fflutter-install%2F</url>
    <content type="text"><![CDATA[安装Flutter 在国内安装使用Flutter，首先阅读下这篇文章，由于国内网络大环境问题，需要提前进行一点配置。 在国内安装Flutter需要首先需要一个值得信任的国内镜像。在镜像上边保存着Flutter需要的依赖及相关库，包等。为了使用Flutter，需要使用一个备用存储位置，我们需要配置环境变量。配置环境变量名：PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL。 在windows系统中，需要在环境变量设置中添加：PUB_HOSTED_URL ： https://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URL ： https://storage.flutter-io.cn 然后运行Git命令（前提是安装了GitBash工具）：git clone -b dev https://github.com/flutter/flutter.git Flutter Flutter文件夹需要注意：文件夹存放的路径上不要出现空格，否则在IDE中进行工程创建后会有警告，SDK环境路径上存在分隔符。 在clone完成之后，即flutter sdk下载完毕，还需要配置Flutter环境： xxxx/Flutter/bin目录下。 重新打开一个命令行，在其中输入命令 flutter doctor 进行环境及缺失的依赖检查，并下载需要的依赖。运行效果如下图： 在环境及相关依赖检查完成之后，可以开始在Android Studio中进行创建工程行为。 注意：Android Studio 预览版中无法保证运行Flutter成功。因此需要使用稳定版AS，且需要3.0版本以上。Android Studio中需要安装Flutter Plugin，Dart Plugin两个插件。 Dart SDK也需要手动安装，直接下载zip包免安装。 成功准备好IDE环境之后，就可以创建Flutter Project了，默认创建Flutter Application就可以了，按照IDE创建提示一直到最终完成。 需要注意：同样由于网络环境，直接运行Flutter Project是不可行的，UI会一直停留在Gradle正在初始化工程。这时需要修改build.gradle配置中的中央Maven库到一个可信赖的公共Maven库。 这里我修改成Ali的Maven库 buildscript { ext.kotlin_version = &apos;1.1.51&apos; repositories { maven { url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; } google() } // ...... } // ...... allprojects { repositories { maven { url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; } } google() } // ...... 然后再次sync工程，进行运行。 首个创建的Flutter Project工程结构如下： 再来看看运行效果： 至此，Flutter，Dart环境均准备结束了。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter简述]]></title>
    <url>%2F2018%2F03%2F12%2Fflutter%2Fflutter-introduction%2F</url>
    <content type="text"><![CDATA[Flutter是Google移动UI框架，用以创建高质量的native接口，真正跨平台，同时在iOS和Android上运行。Flutter是免费开源的，全球开发者及组织均可以使用。 Flutter有又几个特点： 快速开发 毫秒级别的加载速度，快速的渲染启动。 极具表现力，灵活的UI 接近native用户体验的特性。分层结构更是允许完全，从而可以非常快速的渲染且灵活。 native性能 Flutter组件包含所有主要平台的差异，例如滚动，导航，图标和字体，从而提供了在iOS和Android一样的native性能体验. 快速开发 Flutter热加载技术有助于你快速且简单地进行试验，构建UI，增加特性，并且快速修复bug。体验不到一秒的重新加载体验。 漂亮的UI Flutter内置MD设计风格及iOS组件，更有丰富的手势API，流畅的滚动体验和平台认同感会让用户感到愉悦。 查看组件 现代的响应式框架（Modern，reactive framework） 利用Flutter响应式框架和丰富的平台，布局和功能组件是的UI构建非常简单。使用灵活并且强大的API（2D，动画，手势，性能等）可以解决在UI上各种问题。 12345678910111213141516171819202122232425262728class CounterState extends State&lt;Counter&gt; &#123; int counter = 0; void increment() &#123; // Tells the Flutter framework that state has changed, // so the framework can run build() and update the display. setState(() &#123; counter++; &#125;); &#125; Widget build(BuildContext context) &#123; // This method is rerun every time setState is called. // The Flutter framework has been optimized to make rerunning // build methods fast, so that you can just rebuild anything that // needs updating rather than having to individually change // instances of widgets. return new Row( children: &lt;Widget&gt;[ new RaisedButton( onPressed: increment, child: new Text('Increment'), ), new Text('Count: $counter'), ], ); &#125;&#125; 查看组件及学习更多有关reactive framework 访问native特性和SDKs 通过使用平台APIs，第三方SDK和native代码，可以灵活地实现App。Flutter可以让你在iOS和Android上复用Java，Swift和Objective-C代码以及访问native特性和SDKs。 Flutter平台特性访问十分简单。下边是Flutter内interop example]示例： 123456789101112Future&lt;Null&gt; getBatteryLevel() async &#123; var batteryLevel = 'unknown'; try &#123; int result = await methodChannel.invokeMethod('getBatteryLevel'); batteryLevel = 'Battery level: $result%'; &#125; on PlatformException &#123; batteryLevel = 'Failed to get battery level.'; &#125; setState(() &#123; _batteryLevel = batteryLevel; &#125;);&#125; 学习如何使用packages，或者platform channels来访问native代码，APIs及SDKs。 统一的开发标准 Flutter拥有工具及库帮助你简单快速地在iOS和Android上实现你的想法。若你还没有任何移动开发经验，那么Flutter将会是你构建漂亮的移动APP的一种简单快速的额方式。若你是有经验的iOS或者Android开发人员，那么你可以使用Flutter组件，并且继续使用已有的Java/Objective-C/Swift程序。 构建 漂亮的APP UI 丰富的2D GPU加速APIs 响应式框架 动画/动作 APIs 兼容Android Material组件及苹果组件样式 流程的编码体验 急速热加载技术 IntelliJ：重构，自动补足功能等 Dart语言及核心库 包管理 拥有App所有特性 与移动OS APIs&amp;SDKs互操作性 Maven/Java Cocoapods/ObjC/Swift 优化 测试 Unit测试 继承测试 无设备测试 Debug IDE debug 基于网络debug 异步/唤醒感知 表达式求值程序 配置 时间线 CPU和内存 应用性能图标 部署 编译 Native ARM程序 消除无效代码 发布 App市场 Play Store 可以在技术概览了解更多Flutter的特殊性。 原文地址]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离线下载Android SDK（100%成功）]]></title>
    <url>%2F2017%2F10%2F30%2Fhow-to-download-android-sdk-offline%2F</url>
    <content type="text"><![CDATA[最近想在自己的电脑上搭建android开发环境了，由于电脑上很干净（没有任何开发环境），也就是从零开始，虽然知道sdk下载地址被墙了（那个墙很坑爹，好的资源都被墙）。 这里说的方法并非打开sdk-manager.exe的方式，因为这种方式只在android-sdk_r24.4.1-windows.zip之后就不再更新相同的方式了，算是里程碑了。再后边的版本只有一个tools文件夹了，换了文件格式，在windows下没有sdk-manager.exe了。也不是打开Android Studio的settings里边的Android SDK项就可以更新了，因为更新地址被墙了。。。。。。。。即使打开了代理也未必成功！！！ 下面说的方式有点儿傻瓜式，但肯定能成功，这个方法还不能成功，那就是人品问题了。 开始吧！！！！！ 首先下载最新的Android Studio，因为官网提供的Android Studio内不包含SDK环境，所以同时需要下载SKD Tools 第二打开Android Studio，进入Settings -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK 选项卡，首先设置SDK路径，即下载的SDK Tools路径，如下：按照顺序设置结束。 在选择SDK Update Sites。查看图中红框中的Android Repository。 将地址复制出来，https://dl.google.com/android/repository/repository2-1.xml，改地址在不同版本发布时可能有所不同，在浏览器中打开xml文件（应该是需要翻墙的），如下图：文件内数据太多，太大，往下拉，可以从打开的文档中可以看到，所有sdk配置，包含了tools，platform-tools等zip文件文件名（早起版本中提供了完整的下载地址），24版本之后就没有提供完整地址了。 将https://dl.google.com/android/repository/ + “需要的zip文件名”拼接在一起，粘贴到浏览器地址栏中，或者打开迅雷的等下载工具可以直接下载。 这种方式很傻瓜式，有些笨，但100%可以成功，且现在的网络速度很快，相信花不了多少时间就可以完成整个SDK的下载。 在网上最多的还是 找到国内镜像地址进行配置更新，但这种方法还需要看服务器内数据是否是最新的，很可能更新不及时。 通过ping dl.google.com来找到相关的服务器的方式，但这种方式缺陷是可能找到的海外服务器地址，一个都没法使用。 所以现在的这个方式是最靠谱的。程序员也可以自己写段程序处理xml文件，输出所有的下载地址，然后在迅雷中批量下载！！！！OK了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>sdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trap3——Fragment中定制ActionBar（同一个Activity内多个Fragment）]]></title>
    <url>%2F2017%2F10%2F11%2FTrap-Of-Customizing-ActionBar-in-Fragment%2F</url>
    <content type="text"><![CDATA[在最新的design提供了ToolBar来更加自由地定制，使用ActionBar，在布局文件中可以更加灵活地使用。 项目中实际遇上，首页三个tab页面内，ActionBar样式，功能均不同。ViewPager内不同的Fragment，需求的样式不同，菜单功能不同。 但处于同一个Activity内，一般情况下，一个Activity内只布局一个ActionBar（ToolBar）即可，但出于灵活布局，减少Fragment，Activity之间依赖，考虑在每个Fragment内均布局一个ActionBar（ToolBar），在Fragment内通过与原有ActionBar相同的调用来设置Activity对ActionBar的支持及相关属性设置。 @BindView(R.id.my_toolbar) Toolbar mActionBar; ((AppCompatActivity) getActivity()).setSupportActionBar(mActionBar); ActionBar actionBar = ((AppCompatActivity) getActivity()).getSupportActionBar(); if (actionBar == null) { return; } actionBar.setDisplayShowTitleEnabled(false); actionBar.setDisplayShowCustomEnabled(true); actionBar.setDisplayShowHomeEnabled(false); actionBar.setDisplayUseLogoEnabled(false); actionBar.setDisplayHomeAsUpEnabled(false); 这样就实现了在Fragment中实现Activity对ActionBar的显示及相关定制。 但此处为解决的问题是，在三个Fragment中均设置了ActionBar，在对应Fragment显示的时候，除了首个ActionBar正确，其他Fragment的ActionBar均不正确。 尚待解决。。。。。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Trap</tag>
        <tag>ActionBar</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trap2——Fragment中嵌有ViewPager（FragmentPagerAdapter）]]></title>
    <url>%2F2017%2F10%2F11%2FTrap-of-ViewPager-in-Fragment%2F</url>
    <content type="text"><![CDATA[项目需求中，需要实现app首页下部有三个tab，首个tab内部又有多个顶部tab效果。 首先考虑的是外部容器三个页面使用Fragment实现，首个tab内部又有多个tab对应的页面，即fragment。实现考虑使用ViewPager+TabLayout方式实现。 实现中问题： app每次打开，ViewPager首次加载显示正常，在切换之后再返回ViewPager，会发现tab页面消失。 原因：ViewPager内放置Fragment使用FragmentPagerAdapter时，传入的FragmentManager对象有问题。创建FragmentPagerAdapter时，代码如下： new HomeFragmentAdapter(mActivity.getSupportedFragmentManager(), fragments); 需要注意，此刻创建FragmentPagerAdapter本身是在一个Fragment中创建的，即在Fragment使用FragmentPagerAdapter，所以造成了上述情况。 解决方法：创建FragmentPagerAdapter时传入ChildFragmentManager对象，即使用容器Fragment来获取ChildFragmentManager对象。 new HomeFragmentAdapter(Fragment.getChildFragmentManager(), fragments); 这样可以解决这个问题。 在打开app后，home返回桌面，使用360等工具查杀后再打开，Fragment状态错乱 在app被查杀时，Fragment等组件保存的页面状态只是部分信息，不会将页面内所有数据类似快照一样保存完整，因此再次打开app时，页面内部数据恢复，其他部分无法恢复，造成显示错乱。 目前解决办法：在每次打开app时，将Fragment原先保存在保存在状态清除，恢复最初状态。在super.onCreate(savedInstanceState );之前调用。 // 再利用三方软件回收，查杀进程后，删除activity中fragment包含的状态 if (savedInstanceState != null) { String FRAGMENTS_TAG = &quot;android:support:fragments&quot;; savedInstanceState.remove(FRAGMENTS_TAG); } 这样可以解决在突然被查杀后，再次打开时显示错乱问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Trap</tag>
        <tag>Fragment</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trap1——在不同版本上使用FloatingActionButton]]></title>
    <url>%2F2017%2F08%2F30%2FTrap-Of-Using-FloatingActionButton-on-different-android%2F</url>
    <content type="text"><![CDATA[由于项目需求，要实现一个比较吸引人的交互设计。设计类似效果： 在实现前就考虑到design包内提供有一个FloatingActionButton组件可以来实现这个效果。FAB组件继承自ImageView，可以使用ImageView的所有属性。使用组件遇到问题： 组件内icon太小问题 除了layout_width， layout_height属性外，FAB又另外提供app:fabSize属性来设置FAB大小，且只支持此属性来改变FAB大小，其有”auto” “mini” “normal”三个属性值。 auto 基于窗口大小来确定FAB大小 mini FAB最小大小 normal FAB正常大小 尝试设置layout_width, layout_height来自定义FAB大小，同时设置fabSize属性，最终效果内，icon会被撑大或者看不到边缘，因此自定义width，height大小值来改变FAB大小是行不通的。 目前的方法是通过仅设置android:scaleType=“center”来避免系统在渲染时对icon进行大小改变操作（centerInside，centerCrop等属性存在icon大小改变情况）。 重写（override）normal，mini对应的dimen值，即fab_size_normal和fab_size_mini的值。 方法2暂未测试，却是可行的——dimens.xml &lt;resources&gt; &lt;dimen name=&quot;fab_size_normal&quot;&gt;100dp&lt;/dimen&gt; &lt;/resources&gt; 在引用是会引用到重写后的值。 PS：FAB组件需要配合CoordinatorLayout使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Trap</tag>
        <tag>Widget</tag>
        <tag>FloatingActionButton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android资源获取方式]]></title>
    <url>%2F2017%2F08%2F05%2Fandroid-v4-res-jotting%2F</url>
    <content type="text"><![CDATA[Android v4包已经更新过多个版本，在不同版本也新增加诸多新API，方便了开发人员的使用，这里要说的是针对资源获取的新API。新API给予了开发人员很大的方便，无须再像以前一样判断版本号，使用不同的方式去调用。 ContextCompat 完整限定名：android.support.v4.content.ContextCompat此类是Context的帮助类，在API 22（即5.0【LOLLIPOP_MR1】）中添加，其中提供诸多静态方法以方便调用。 此间我关注的是资源的获取方法： static final int getColor (Context context, int id)此方法在6.0（M）时添加，获取对应id的颜色资源。此方法返回的是带有系统主题风格的颜色。 static final Drawable getDrawable (Context context, int id) 此方法在5.0添加，获取id对应的Drawable可绘制对象。 ResourcesCompat 完整的限定名： android.support.v4.content.res.ResourcesCompat此类是Resources的帮助类。此类中获取资源的所返回的资源可以是与系统主题风格无关的资源。 static int getColor (Resources res, int id, Resources.Theme theme)同样获取颜色值，但其theme参数可以传入null，即不与当前Context主题相关。 static Drawable getDrawable (Resources res, int id, Resources.Theme theme)此方法获取可绘制Drawable资源。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取运行进程解决方案分析]]></title>
    <url>%2F2017%2F06%2F08%2Fget-running-processes-above-android-lollipop%2F</url>
    <content type="text"><![CDATA[在Android中获取运行进程这种需求在许多场合需要被使用到，但实际情况是在Android Lollipop即5.0后，Google开始收紧对底层权限控制。下面就涉及的方法及我现在找到的解决方案来分析下，是如何解决这个问题的。 可以从原有的几个方法的API变化及调用返回看出。 getRunningAppProcesses()在直到4.x， 5.0版本上工作良好（即便API中提示此方法仅用于debugging及编译管理UI之用），但从5.0+开始在一些OEM的系统中调用此方法进行测试会发现方法返回null。 getRunningTasks (int)方法从5.0起正式被标记为deprecated（过时）。5.0+版本上的第三方应用无法在引用此方法。原因在于调用者可能利用此方法获取的私人信息，导致信息泄露。而为了向后兼容，在原有的版本中依然可以获取到至少调用应用本身的task信息及部分其他不敏感的信息。 从上述两个方法的变化可以看出在5.0+之后，想要获取运行进程越来越难。 在5.0~6.0版本上，利用此处的解决方法还可以获取当前运行的进程列表。AndroidProcesses方案可以获取当前的运行进程列表。 这里的入口方法最常使用的是AndroidProcesses类的getRunningProcesses()。 在查看到具体实现后，就可以知道，这个解决方案一般的android开发人员是真想不到的，因为涉及到linux的文件系统，只有真正熟悉linux内核了解linux filesystem的开发人员才能想到此种办法。 这里主要涉及到文件系统中/proc目录。/proc文件系统目录是一个伪文件系统，它只存在内存当中，而不占用外存空间。它是在系统运行时产生于内存当中。linux通过这一伪文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。 /proc目录下有这诸多的文件和目录 在/proc目录下，进程名均是以数字命名的目录。因此获取运行进程信息，即是访问数字命名的目录，通过读取目录内特定文件来获取对应的进程名。 读取进程名分成以下几步： 读取进程目录下cmdline文件内容，android系统中该文件内包含的既是文件名。通过ps命令可以查看到当前android中的进程。然后再cat文件内容查看： cmdline内容也可能是空，具体原因不明。此种情况下，换做去读取/proc/pid/stat文件。stat内容格式：内容是空格分割的多列，其中第二列既是当前进程的进程名。 以步骤1、2访问/proc目录内所有数字命名目录， 即可以获取到当前Android系统中正在运行的进程。 在获取进程之后，我们就可以根据需要进行某些操作了。 据说google在7.0上有加强了对/proc目录访问的控制，AndroidProcesses的解决方案就有问题了…….. 持续关注此问题后续可能的解决方案中……]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建个人微博——手把手教]]></title>
    <url>%2F2017%2F06%2F01%2Fhow-to-setup-personal-blog-width-hexo-and-github%2F</url>
    <content type="text"><![CDATA[文章有点儿长，不过解释很清晰，有兴趣的朋友请耐心看完，肯定能搭建成功！^_^ 这里因为使用的是windows系统，所以选择了Hexo这个微博框架。 原来想使用与GitHub结合更有优势的jekyll，但是由于系统的问题，就放弃了。下来就如何来搭建吧！！！ 先说说怎么会想到搭建个人微博 工作多年，没有认真整理过自己工作中的经验，遇到的问题及解决方案。因此想着认真整理下过去到现在过程中的问题。废话不多说，下来看看我是如何来搭建我的个人微博的。 前提条件 需要有个github账号。一般做为一个开发人员，github肯定是访问过的，相信绝大多数开发人员会注册拥有一个github账号，因为这是全球知名的代码托管网站。全世界均可访问到它。若还没有可以到Github注册。 基本软件NodeJS，Git，Hexo在机子上需要使用到NodeJS进行部署，安装插件等。下载NodeJs。安装Git，进入Git下载页面选择合适的版本进行下载。如果不清楚Hexo是什么？？她是一个快速，简介，高效的博客框架。更多详情可以到Hexo官网读下这个文档就知道了。O(∩_∩)O哈哈~ 安装完成Git及NodeJs后，那么就可以开始准备安装Hexo了。打开GitBash，使用npm命令来安装Hexo程序。 回车，等待安装，安装完成后有如下信息：…….. 这样表示Hexo安装成功了。到此，搭建个人微博需要的3个软件就安装完成了。 接下来就需要进行相关配置及插件安装了。所有的操作均在GitBash命令行中进行操作。 建站 首先简历一个简单的站，创建初始化一个简单的文件夹。 $ hexo init myGitPages $ cd myGitPages $ npm install 这样就可以新建所需要的文件。安装完成后，可以看到如下的几个主要文件。 其中:_config.xml 可以配置网站信息。可以参考配置package.json 应用程序信息。有默认配置一些组件，可以自己根据需要添加或者移除。scaffolds 模板文件夹。当新建文章时，Hexo会根据scaffold来建立文件。source 资源文件夹，存放用户资源的地方。themes 主题文件夹。Hexo会根据主题来生成静态页面。 主题 Hexo可以有很多主题，在Github首页搜索框内输入”hexo theme”，可以搜索到很多主题，目前我使用的是litten的yilia主题。 可以在进入到建立的站点文件夹下（我的是myGitPages）下，下载yilia主题 $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载完成后，打开站点个目录下（myGitPages）的_config.xml文件，修改其中的theme属性成 theme: yilia 这样就可以在发布文章的手看到修改的主题，或者通过hexo server进行查看。 发布 发布文章前一定要确认已经安装了hexo-deployer-git插件，否则无法正常发文章到git上的。 $ npm install hexo-deployer-git --save 来安装git插件。 到目前基本上需要的从博客站点建立，到发布所需要的软件准备工作都就绪了。 PS：yilia要显示所有文章还需要进行一个配置，下文会写到。 在开始写文章发布之前可以，先查本地运行查看Hexo运行情况，运行 $ hexo server 启动服务器。默认情况下，端口地址是4000。打开浏览器，访问：http://localhost:4000查看效果。若访问出错，没有打开页面，那么可能是端口被占用导致。此时可以使用 $ hexo server -p 5000 修改端口，然后重新输入端口号进行查看。若访问成功，默认看到的是hello-wold.md（即source/_post文件夹下的默认创建文件）文件发布后的效果。 准备工作结束，可以开始写文章发布 上述工作都结束后，可以进入到站点文件夹/source/_post/目录下新建md文件，使用Markdown标记语言写一些内容。 Markdown标记语言使用比较简单，可以在这里学习简单的使用，或者markdown.cn学习使用。 在写完文章之后就需要将写的文章部署到GitHub上去了。来看下这个过程。 由于要发布博客到GitHub实际上使用了GitHub Pages功能，因此可以到这里来查看相关的介绍。其中详细介绍了Pages概念，及如何建立自己的站点。 一下先简绍下我自己的建立过程。 建立GitHub仓库 建立仓库，用以部署Hexo生成的博客。如果还没有GitHub账号就需要注册了。有GitHub账号的小伙伴可以到Github网站创建一个新仓库，如下显示。 其中仓库名有所讲究，它必须是username.github.io ，这里的username有两种情况，其一是你的用户名即注册时使用的名称，其二是组织名称（此处组织名称并未尝试）。如下图可以看下位置。 Hexo发布前需要配置_config.xml 在使用Hexo发布博客之前，当然还需要让Hexo知道要发布到什么地方。 在站点根目录下（myGitPages），找到并编辑_config.xml文件，如下部分： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:techinsight/techinsight.github.io.git branch: master message: 将新建的仓库信息及分支信息配置到_config.xml，让Hexo知道部署到GitHub的那个仓库。 发布 最后，就需要发布了。可以在站点根目录下（myGitPages）下运行一下命令： $ hexo clean #清除原有生成的相关文件 $ hexo generate #重新生成静态页面 $ hexo deploy #进行部署 在运行部署命令时，会弹出ssh密码输入确认框，输入username.github.io仓库密码，点击OK即可进行顺利发布。 然后就去访问你的个人站点吧。你会看到发布的文章。 PS: 不同的主题可能在主题中还需要进行一定的配置，这个看个人喜好使用哪个主题，我使用的是yilia主题，其在初次查看所有文章时会发现展示的不是文章列表。那么按照主题作者提示进行配置后，重新部署就可以了。 nodejs版本大于6.2（最新的nodejs肯定符合）。 在博客根目录下（不是yilia根目录下）执行如下命令： npm i hexo-generator-json-content –save 在根目录_config.xml文件内配置： &nbsp;&nbsp;&nbsp;&nbsp;# 查看yilia主题下所有文章配置 &nbsp;&nbsp;&nbsp;&nbsp;jsonContent: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meta: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pages: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; posts: &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; title: true &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; date: true &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; path: true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slug: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; updated: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comments: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; permalink: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excerpt: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tags: true]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>微博</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多进程app中Application回调onCreate()方法被执行多次分析及解决]]></title>
    <url>%2F2017%2F05%2F28%2Fandroid-multiprocess-oncreate-executed-serval-times%2F</url>
    <content type="text"><![CDATA[问题描述 最近工作中碰到一个问题，在优化app，使用DDMS查看Application log过程中看到，app启动了三个进程，一个主进程，两个附带的进程。如下图可看到一个app启动的三个进程。 自定义Application回调方法onCreate()被执行了3次。开始不知是何原因。 相关知识 android:process 从Android开发者文档中的manifest中进程配置android:process可以获知:正常情况下，应用程序的所有组件运行在一个默认的进程名下，因此不需要使用这个属性。但在需要的情况下，可以通过使用这个属性来覆盖默认进程，这样一个app就跨越多个进程。 如果这个属性值以冒号（“:”）开始，说明新进程相对于应用程序是一个私有进程，且组件运行在此进程中。若属性值以小写字符开始，那么新进程即是一个全局进程，组件运行在这个全局进程中。这也意味着其他应用程序组件可以与此进程进行通信，减少资源使用。 标签&lt;application&gt;的android:process属性可以为整个app内组件设置一个默认的运行进程。 manifest中组件标签&lt;activity&gt;， &lt;service&gt;， &lt;provider&gt;, &lt;receiver&gt;都支持配置android:process，即每个组件均可以创建运行在自己的一个新进程中。 Application类 我们可以自定义继承Application类来实现自己的Application，然后在其中的onCreate()方法中进行一定的初始化工作。 若自定义了Application类，那么需要注意的就是这个类在当app中有多个进程时，每个进程启动时都会初始化一次Application。在Android中很不幸的就是我们无法为每个新创建的进程来分别创建一个Application类。 解决方案 第一：getRunningAppProcesses() 每个进程对应一个application，这样可以通过针对特定进程名，进行相应的初始化工作，避免资源浪费，执行时间消耗。 因为Application的执行时间影响着首个activity，service等的启动时间。即Application执行时间越长，首个组件（activity）启动时间越晚，给用户造成的感觉就是应用启动速度特别慢。 可以看出，Application回调方法onCreate()被执行3次，均执行耗时操作，这样造成了在点击应用logo后，到看到进入app，首个页面（Activity）启动，耗时将近6s，外加处理器速度，在较慢的机器上，这个时间可能更长，甚至超过10s。 目前较多采用的方法既是所提到的根据具体进程来进行相应的初始化工作，核心的获取对应进程的方法如下： /** * 获取进程名。 * 由于app是一个多进程应用，因此每个进程被os创建时， * onCreate()方法均会被执行一次， * 进行辨别初始化，针对特定进程进行相应初始化工作， * 此方法可以提高一半启动时间。 * * @param context 上下文环境对象 * * @return 获取此进程的进程名 */ private String getProcessName(Context context) { ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcesses = am.getRunningAppProcesses(); if (runningAppProcesses == null) { return &quot;&quot;; } for (ActivityManager.RunningAppProcessInfo runningAppProcess : runningAppProcesses) { if (runningAppProcess.pid == android.os.Process.myPid() &amp;&amp; !TextUtils.isEmpty(runningAppProcess.processName)) { return runningAppProcess.processName; } } return &quot;&quot;; } 这样经过测试，在不同的进程被创建时，进行不同的工作，执行时间可以缩短一半。 虽然这种方法在某些版本上可以奏效，在但Android 5.0+版本中，由于Google开始收紧对Android底层权限管理，在趋势上方法getRunningAppProcesses())将会被毙掉。因为已经在一些版本的环境中，此方法返回null。 第二：UsageStatsManager 使用类UsageStatsManager来获取运行的apps列表，但是使用这个类需要添加一个权限PACKAGE_USAGE_STATS，而此权限是系统权限，要使用必须到Settings应用中去针对应用进行授权（我们的app用户肯定不会愿意多次一步）。另外，据称有些OEM厂商已经删除了此项设置，换言之在Settings中找不到授权入口。 因此这个途径也就被毙掉了。 最终方案 经过几天google方案及针对可能的解决方法进行测试，下边的这个感觉比较靠谱。 这是一个开源项目，项目地址点击这里。 在我们的Application中集成并测试了该方法。 源码中添加一个方法，类似于使用getRunningAppProcesses()方法一样： 以下是在三个不同的Android版本进行测试结果： 可以看到，针对这三个版本是可以达到相关初始化代码只执行一次的效果。这样可以缩短启动消耗的时间。 更多版本类型测试大家可以自行进行测试。 时间原因，此方案的代码及解决方法还没有来得及跟踪，有时间在做分析…… 这种方案也有限制： 一些版本的系统应用不包括在内，因为他们具有更高级别的SElinux context； 这种方法也不是getRunningAppProcesses())完全的替代，因为它无法给出集成的pkgList，lru和importance信息； 此库在7.0开发者预览版本上是无法起作用的。 下面的一篇文章就来分析下此方案是如何解决读取进程的——&gt;《Android获取运行进程解决方案分析》]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>Application</tag>
      </tags>
  </entry>
</search>
