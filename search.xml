<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter(四) 搭建布局]]></title>
    <url>%2F2018%2F04%2F11%2Fflutter%2Fflutter-building-layouts%2F</url>
    <content type="text"><![CDATA[你将学习:&nbsp;&nbsp;- Flutter布局机制如何工作&nbsp;&nbsp;- 如何竖直或横向展示组件&nbsp;&nbsp;- 如何搭建Flutter布局 这篇文章说明Flutter搭建布局。我们将学习搭建布局，做种效果如下截图： 这篇引导退一步来解释Flutter进行布局的方式，以及展示如何在屏幕上放置一个单独的组件。在学习完如何横向或竖向展示组件之后，我们会再看到些常用的布局组件。 搭建布局 Step 0：创建 Step 1：图解布局 Step 2：实现标题行 Step 3：实现按钮行 Step 4：实现文本区域 Step 5：实现图片区域 Step 6：集成上述组件 Flutter布局方法 布局一个组件 横向及竖向布局多个组件 组件对齐方式 调整组件大小 缩紧组件 嵌套行与列 常用布局组件 标准组件 Material组件 资源 搭建布局若你想理解“big picture”的布局原理，那么需要学习Flutter布局方法。 Step 0：创建首页获取代码： 确定已经设置好环境 创建基本Flutter工程 下来在工程中添加图片： 在工程根目录创建images目录 添加 lake.jpg 图片 更新 pubspec.yaml 文件，添加 assets 标签 Step 1：图解布局第一步是将布局分解成基本元素: 区分行与列。 布局是否包含一个网格？ 是否有层叠元素？ UI是否需要tabs？ 注意需要对齐，内边据或者边框的区域。 首先，识别更大的元素。在这里，四个元素在同一列中：一个图片，两行和一个文本块。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter(三) 入门：学习更多]]></title>
    <url>%2F2018%2F04%2F11%2Fflutter%2Fflutter-get-started-learn-more%2F</url>
    <content type="text"><![CDATA[学习更多有关Flutter的framework 构建布局(Building Layouts) 教程 交互(Add Interactivity) 教程 Flutter组件框架(Flutter Widget Framework) Android开发者使用Flutter(Flutter for Android Developers) 其他资源 Flutter详尽说明(Flutter Cookbook) Java转向Dart(From Java to Dart) 指引 Dart程序：学习更多Dart知识 学习愉快。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter(二) 创建第一个Flutter APP]]></title>
    <url>%2F2018%2F03%2F29%2Fflutter%2Fflutter-create-your-first-app%2F</url>
    <content type="text"><![CDATA[这一章主要是创建一个Flutter App。如果你熟悉面向对象编程，有基本的编程概念（变量，循环，条件判断等），那么你不必要具备原有的Dart和移动开发经验，就可以轻松地理解完成这章内容。 Step 1：创建第一个flutter app Step 2：使用外部包 Step 3：添加一个有状态的组件（Stateful widget） Step 4：创建无限滚动ListView Step 5：添加交互 Step 6：跳转到另一个屏 Step 7：利用主题改变UI 构造什么 你将为一家初创公司实现一个简单的移动app，主要功能是为这家公司推荐名字。用户可以选择或者取消名字，保存最好的名字。程序会一次性产生10个名字。在用户滚动时，新名字同时会产生出来。用户可以点击导航栏（appbar）的列表图标进入到一个新的列表页查看喜欢的名字。 最终的结果最后运行结果中可以看到。 你将会学到： Flutter app基本结构 查找并使用包来扩展功能 使用热加载加快开发周期 如何实现一个有状态组件（Stateful widget） 如何创建一个无限，懒加载列表 如何创建并路由到第二个屏幕 如何使用app主题修改外观 你将会使用：需要安装： Flutter SDKFlutter SDK包含了Flutter引擎，framework，组件，工具，和Dart SDK。这份代码实验需要v0.1.4或者更高版本。 Android Studio这次代码实验需要Android Studio。也可以在命令行。 需要IDE插件IDE上必须分别安装Flutter和Dart插件。 查看Flutter安装学习如何建立起你的Flutter环境 Step 1：创建Flutter App 创建第一个简单的，IDE提供模板的Flutter App，可以按照引导创建Flutter工程。我将工程名命名为flutter_app，这个按照个人习惯吧，只要名称合法就行。 在这节程序实验中，最多编辑的会是lib/main.dart，其中就是Dart代码。 Tips：当你粘贴代码到IDE中的时候，可能发生缩进不对齐的情况。你可以使用Flutter工具来解决这种问题： 1. Android Studio/IntelliJ IDEA：右单击Dart代码，选择Refactor code with dartfmt 2. VS Code：右单击选择 Format Document 3. Terminal：运行命令 flutter format filename。 替换模板的lib/main.dart移除原有工程中的模板代码lib/main.dart。输入如下代码，可以查看到UI中间显示的“Hello World”。 1234567891011121314151617181920import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123;truereturn new MaterialApp(true title : 'Welcome to Flutter',true home:new Scaffold(truetrueappBar:new AppBar(truetrue title:new Text('Welcome to Flutter'),truetrue),truetruebody:new Center(truetrue child:new Text('Hello World'),truetrue),true ),true); &#125;&#125; 运行app，可以看到如下执行效果 结果 这个例子创建了一个Material app。Material是在移动端和web端上的设计标准。Flutter提供了丰富的Material组件。 main()方法声明了胖箭头(=&gt;)符号表示法，这种写法表示了man()方法是一个单行函数，即函数体只有一行代码构成。 App继承StatelessWidget，这也使得App本身成为了一个组件。在Flutter中，几乎所有对象都被认为是一个组件，包含对齐方式，内边距和布局。 Material组件库中的Scaffold提供了App默认需要的appbar，title，和body属性，body属性包含了home screen的组件树结构。组件的子组件结构可以相当复杂。 组件的主要工作就是提供build()方法，描述如何展示自己及其他组件。 这个例子中组件结构有一个Center组件中包含一个Text子组件组成。Center组件将其内的组件结构置于屏幕中央。 Step 2：使用外部包 这一步中，你将使用开源包english_words。这个包中包含了几千个最常用的英文单词和一些实用方法。 你可以在pub.dartlang.org找到english_words包，同时还有其他的开源包。 文件pubspec.yaml管理者Flutter App的资源。在pubspec.yaml中，添加english_words（3.1.0或者更高）到依赖列表。如下代码中： 12345678910...dependencies: flutter:sdk:flutter # The following adds the Cupertino Icons font to your application. # Use with the CupertinoIcons class for iOS style icons. cupertino_icons:^0.1.0 english_words:^3.1.0 ... 原有模板文件中代码太多（包含注释），不全部展示出来。这里在depenencies下添加english_words包依赖。 在Android Studio编辑器中查看pubspec.yaml文件时，可以看到编辑器右上方有命令操作栏，点击Package get。这就是获取english_words包操作。你会在控制台命令行看到： 在lib/main.dart中，添加对english_words包的导入，如下显示的导入语句： 12import 'package:flutter/material.dart'; import 'package:english_words/english_words.dart'; 在你输入后，AS会因为你写的导入语句给出建议。表现在你输入的导入语句会变成灰色，这就是提示你导入的库还没有使用过。 使用english_words包来生成文本，而不再显示“Hello World”Tips：“Pascal case”(大驼峰规则)意思是在一个字符串中的每个单词，包括第一个单词，都是以大些字母开头。因此，“uppercamelcase”就是”UpperCamelCase”。 针对原有代码做出修改 12345678910111213141516171819202122import 'package:flutter/material.dart'; import 'package:english_words/english_words.dart'; void main() =&gt; runApp(new MyApp()); class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; final wordPair = new WordPair.random(); true return new MaterialApp( true title:'Welcome to Flutter', truetruehome:new Scaffold( truetrue appBar:new AppBar( truetrue title:new Text('Welcome to Flutter'), truetrue ), truetruebody:new Center( truetrue child:new Text(wordPair.asPascalCase), truetrue ), truetrue), true ); &#125; &#125; 如果App正在运行，使用热加载按钮更新app。每次点击热加载按钮，或者进行保存时，你应该都能在运行的app上看到随机选取的不同的单词对。这是因为单词对是在build()方法中产生，build()方法每次在MaterialApp需要渲染或者在Flutter Inspector中打开Platform时被执行。 Step 3：添加有状态组件 无状态组件(Stateless widget)是不可变的，意味着他们的属性无法改变——所有值是final的。 有状态组件(Stateful widget)维持一个状态值，此状态值会根据组件生命周期而有所改变。实现一个有Stateful widget需要至少两个类： StatefulWidget类用以创建实例； State类。 StatefulWidget组件本身是不可变的，但是State类在整个组件声明周期过程中是始终存在的。 在这步中，你将会添加一个stateful widget，RandomWords以及创建对应的状态State类，RandomWordsState。State类实际上为组件保留着喜欢的单词对。 在main.dart文件中添加RandomWords组件。这个类可以定义在文件内任意位置，但是我将其定义在文件末尾。 12345class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState(); &#125; 添加RandomWordsState类。大部分的app功能代码都会在这个类中。这个类同时保存用户滚动列表过程中产生的所有单词对，以及用户添加喜欢或者移除的单词对。下面添加对基本的了定义，来保证类文件编译通过 12class RandomWordsState extends State&lt;RandomWords&gt; &#123;&#125; 添加State类之后，IDE会提示缺少一个build()方法。下一步，需要将产生单词对的代码移至这个build()方法中。 在RandomWordsState的build()方法中添加代码，整个文件看起来像这样 1234567891011121314151617181920212223242526272829303132333435import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title:'Welcome to Flutter', home:new Scaffold( appBar:new AppBar( title:new Text('Welcome to Flutter'), ), body:new Center( child:new RandomWords(), ), ), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125;class RandomWordsState extends State&lt;RandomWords&gt; &#123; @override Widget build(BuildContext context) &#123; final wordPair = new WordPair.random(); return new Text(wordPair.asPascalCase); &#125;&#125; 重启App运行。目前修改的代码在运行起来之后，效果与之前的一样，只是将无状态组件换成了有状态组件。 Step 4：创建无限滚动列表 在这步中，你将扩展RandomWordsState类来展示一个列表。列表随着用户的滚动无限增粘。ListView的builder工厂方法可以按需要进行懒加载。 在RandomWordsState中添加 suggestions 列表变量保存生成的候选单词对。变量以 (\) 开头 ——在Dart中，下划线开头的变量强调私有 同时添加比变量 biggerFont 改变字体大小。 123456class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); ...&#125; 在RandomWordsState类中添加 _buildSuggestions()方法。这个类主要功能就是产生需要展示的单词对列表。 Listview提供了builder属性itemBuilder 用以产生item及匿名函数的回调。BuildContext和行的迭代器索引 i ，这两个参数被传到ListView的buil()方法。迭代器索引从0开始增长，每次方法调用产生一个单词对的时候就会增长。这就使得列表在用户滚动时无限增长。增加代码后，整个类看起来就是 12345678910111213141516171819202122232425262728293031323334353637class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); final _saved = new Set&lt;WordPair&gt;(); ..... Widget _buildSuggestions() &#123; return new ListView.builder( padding:const EdgeInsets.all(16.0), // The itemBuilder callback is called once per suggested word pairing, // and places each suggestion into a ListTile row. // For even rows, the function adds a ListTile row for the word pairing. // For odd rows, the function adds a Divider widget to visually // separate the entries. Note that the divider may be difficult // to see on smaller devices. itemBuilder:(context, i) &#123; // Add a one-pixel-high divider widget before each row in theListView. if (i.isOdd) return new Divider(); // The syntax "i ~/ 2" divides i by 2 and returns an integer result. // For example:1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2. // This calculates the actual number of word pairings in the ListView, // minus the divider widgets. final index = i ~/ 2; // If you've reached the end of the available word pairings... if (index &gt;= _suggestions.length) &#123; // ...then generate 10 more and add them to the suggestions list. _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125; ); &#125;&#125; 在 _buildSuggestions()方法中调用了 _buildRow()方法。这个函数作用是在ListTile组件中显示新的单词对。ListTile组件可以让你的每行看起来更加具有渲染力。 在RandomWordsState中添加 _buildRow()方法 1234567891011class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... Widget _buildRow(WordPair pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;&#125; 最后来更新RandomWordsState入口函数build()。整体文件最终代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title:'Welcome to Flutter', home:new RandomWords(), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125;class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); @override Widget build(BuildContext context) &#123; return new Scaffold ( appBar:new AppBar( title:new Text('Startup Name Generator'), ), body:_buildSuggestions(), ); &#125; Widget _buildSuggestions() &#123; return new ListView.builder( padding:const EdgeInsets.all(16.0), // The itemBuilder callback is called once per suggested word pairing, // and places each suggestion into a ListTile row. // For even rows, the function adds a ListTile row for the word pairing. // For odd rows, the function adds a Divider widget to visually // separate the entries. Note that the divider may be difficult // to see on smaller devices. itemBuilder:(context, i) &#123; // Add a one-pixel-high divider widget before each row in theListView. if (i.isOdd) return new Divider(); // The syntax "i ~/ 2" divides i by 2 and returns an integer result. // For example:1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2. // This calculates the actual number of word pairings in the ListView, // minus the divider widgets. final index = i ~/ 2; // If you've reached the end of the available word pairings... if (index &gt;= _suggestions.length) &#123; // ...then generate 10 more and add them to the suggestions list. _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125; ); &#125; Widget _buildRow(WordPair pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;&#125; 最终重新启动App运行。 Step 5：添加交互 这步中，你讲为每行item添加一个可点击的心形图标，在用户点击item时，对应的单词对（word pair）会被添加到收藏或者被移除。 在RandomWordsState类中添加一个 _saved 集合（Set）变量。这个集合保存了用户喜欢并收藏的单词对。之所以使用集合是因为集合可以保证其中没有重复的单词对。 12345678class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); final _saved = new Set&lt;WordPair&gt;(); ...&#125; 在函数_buildRow()中，添加变量alreadySaved来检查用户点击的wordPair是否已经保存。 1234Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); ...&#125; 同样还需要在函数_buildRow()中，需要在ListTiles中添加心形图标来表示收藏状态。后边，你将会为次添加收藏取消功能的交互。 12345678910111213Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), trailing:new Icon( alreadySaved ? Icons.favorite :Icons.favorite_border, color:alreadySaved ? Colors.red :null, ), );&#125; 重启App。就将看到列表中每行右侧添加了一个心形图标。 为每行添加可点击功能。即若被点击的item对应的单词对已经被收藏了，那么就会被取消收藏，反之就添加到收藏。当一个tile被点击，函数调用setState()通知framework状态发生改变。添加的代码如下，在_buildRow()方法中进行添加 12345678910111213141516171819202122Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), trailing:new Icon( alreadySaved ? Icons.favorite :Icons.favorite_border, color:alreadySaved ? Colors.red :null, ), onTap:() &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, );&#125; Tips：在Flutter的响应框架中，调用setState()方法会出发调用State类的bulid()方法，这就导致了更新UI操作。 重运行App。你应该可以通过点击来添加或者取消收藏。注意的一点是，在点击的时候可以看到一个放射性的点击效果，这是Material风格所致。如果有Android开发经验的程序员就会知道。 Step 6：导向新的一屏 在这步中，你将添加一个新屏幕（在Flutter叫做route）来展示你的收藏。你将学习如何在home route和新route之间进行交互。 在Flutter中，导航器(Navigator)管理着所有app route的一个栈。向栈内push一个route就表示这将展示新的一屏。pop出栈表示向前显示一屏。 在RandomWordsState类的build方法中，在AppBar上添加一个列表图标。当用户点击列表icon，包含收藏数据的新的route就会被推送的栈中，并且展示新的一屏。Tips：某些组件属性只包含一个子组件(child)，而某些属性（像action）拥有一组子组件(children)，这种方式通过方括号表示([])。 在方法中添加icon和对应的action: 12345678910111213141516171819202122....class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); final _saved = new Set&lt;WordPair&gt;(); @override Widget build(BuildContext context) &#123; return new Scaffold ( appBar:new AppBar( title:new Text('Startup Name Generator'), actions:&lt;Widget&gt;[ new IconButton(icon:new Icon(Icons.list), onPressed:_pushSaved), ], ), body:_buildSuggestions(), ); &#125; ....&#125; 上边的代码中同时定义了press回到，因此同时需要定义方法 123456class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... void _pushSaved() &#123; &#125;&#125; ... 此处方法中并未添加任何代码。 在用户点击appbar上的列表icon。系统构建一个route并且push到Navigator的栈中。这种操作改变了屏幕的显示，显示了新的route。这个新页面的内容在MaterialPageRoute的builder的匿名函数中构建。 添加调用Navigator.push，将route推送的Navigator栈中。 123456789...class RandomWordsState extends State&lt;RandomWords&gt; &#123; ... void _pushSaved() &#123; Navigator.of(context).push( ); &#125; &#125;... 添加MaterialPageRoute和对应的builder。现在，可以在push方法中添加对应的代码，展示收藏的单词对列表。使用toList()方法转换将最终的数据赋值给divided 变量，使其拥有最终数据。 12345678910111213141516171819202122void _pushSaved() &#123; Navigator.of(context).push(new MaterialPageRoute( builder:(context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context:context, tiles:tiles, ) .toList(); &#125;, ),); &#125; builder属性返回一个Scaffold（包含了新route的appbar）组件命名“Saved Suggestions”。新的route由ListTile组件组成的列表组成，ListTiles之间有分隔符分割。 这样整体的代码如下 12345678910111213141516171819202122232425262728293031void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute( builder:(context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context:context, tiles:tiles, ) .toList(); return new Scaffold( appBar:new AppBar( title:new Text('Saved Suggestions'), ), body:new ListView(children:divided), ); &#125;, ), );&#125; 重运行App。收藏几个单词对，然后点击appbar上的列表icon，将会出现新的一屏来展示收藏的单词对。注意新出现的一页上默认会又给返回按钮，这个Navigator默认添加的。这样你不用特意为返回另外写程序来执行Navigator.pop来返回。点击返回按钮就可以返回到之前的页面。整体代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122import 'package:flutter/material.dart';import 'package:english_words/english_words.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title:'Welcome to Flutter', home:new RandomWords(), ); &#125;&#125;class RandomWords extends StatefulWidget &#123; @override createState() =&gt; new RandomWordsState();&#125;class RandomWordsState extends State&lt;RandomWords&gt; &#123; final _suggestions = &lt;WordPair&gt;[]; final _biggerFont = const TextStyle(fontSize:18.0); final _saved = new Set&lt;WordPair&gt;(); @override Widget build(BuildContext context) &#123; return new Scaffold( appBar:new AppBar( title:new Text('Startup Name Generator'), actions:&lt;Widget&gt;[ new IconButton(icon:new Icon(Icons.list), onPressed:_pushSaved), ], ), body:_buildSuggestions(), ); &#125; void _pushSaved() &#123; Navigator.of(context).push( new MaterialPageRoute( builder:(context) &#123; final tiles = _saved.map( (pair) &#123; return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), ); &#125;, ); final divided = ListTile .divideTiles( context:context, tiles:tiles, ) .toList(); return new Scaffold( appBar:new AppBar( title:new Text('Saved Suggestions'), ), body:new ListView(children:divided), ); &#125;, ), ); &#125; Widget _buildSuggestions() &#123; return new ListView.builder( padding:const EdgeInsets.all(16.0), // The itemBuilder callback is called once per suggested word pairing, // and places each suggestion into a ListTile row. // For even rows, the function adds a ListTile row for the word pairing. // For odd rows, the function adds a Divider widget to visually // separate the entries. Note that the divider may be difficult // to see on smaller devices. itemBuilder:(context, i) &#123; // Add a one-pixel-high divider widget before each row in theListView. if (i.isOdd) return new Divider(); // The syntax "i ~/ 2" divides i by 2 and returns an integer result. // For example:1, 2, 3, 4, 5 becomes 0, 1, 1, 2, 2. // This calculates the actual number of word pairings in the ListView, // minus the divider widgets. final index = i ~/ 2; // If you've reached the end of the available word pairings... if (index &gt;= _suggestions.length) &#123; // ...then generate 10 more and add them to the suggestions list. _suggestions.addAll(generateWordPairs().take(10)); &#125; return _buildRow(_suggestions[index]); &#125;); &#125; Widget _buildRow(WordPair pair) &#123; final alreadySaved = _saved.contains(pair); return new ListTile( title:new Text( pair.asPascalCase, style:_biggerFont, ), trailing:new Icon( alreadySaved ? Icons.favorite :Icons.favorite_border, color:alreadySaved ? Colors.red :null, ), onTap:() &#123; setState(() &#123; if (alreadySaved) &#123; _saved.remove(pair); &#125; else &#123; _saved.add(pair); &#125; &#125;); &#125;, ); &#125;&#125; Step 7：使用主题修改UI 这是最后一步，你将使用theme。主题（theme）主要控制app看起来外表如何。可以使用默认的主题，从文章开始到目前使用的一直是默认的主题。主题不依赖与物理设备或者模拟器。你也可以自定义自己的主题来突显你自己的品牌。 通过ThemeData类你可以很简单的修改app的主题。像下边一样修改下代码，就可以改变页面的主标题主题 123456789101112class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title:'Startup Name Generator', theme:new ThemeData( primaryColor:Colors.white, ), home:new RandomWords(), ); &#125;&#125; 重运行App看看效果。需要注意的是整个的页面背景是白色的，甚至appbar也是白色的。 好了，这章的内容就是这些了。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter(一) 环境准备]]></title>
    <url>%2F2018%2F03%2F15%2Fflutter%2Fflutter-install%2F</url>
    <content type="text"><![CDATA[安装Flutter 在国内安装使用Flutter，首先阅读下这篇文章，由于国内网络大环境问题，需要提前进行一点配置。 在国内安装Flutter需要首先需要一个值得信任的国内镜像。在镜像上边保存着Flutter需要的依赖及相关库，包等。为了使用Flutter，需要使用一个备用存储位置，我们需要配置环境变量。配置环境变量名：PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL。 在windows系统中，需要在环境变量设置中添加：PUB_HOSTED_URL ： https://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URL ： https://storage.flutter-io.cn 然后运行Git命令（前提是安装了GitBash工具）：git clone -b dev https://github.com/flutter/flutter.git Flutter Flutter文件夹需要注意：文件夹存放的路径上不要出现空格，否则在IDE中进行工程创建后会有警告，SDK环境路径上存在分隔符。 在clone完成之后，即flutter sdk下载完毕，还需要配置Flutter环境： xxxx/Flutter/bin目录下。 重新打开一个命令行，在其中输入命令 flutter doctor 进行环境及缺失的依赖检查，并下载需要的依赖。运行效果如下图： 在环境及相关依赖检查完成之后，可以开始在Android Studio中进行创建工程行为。 注意：Android Studio 预览版中无法保证运行Flutter成功。因此需要使用稳定版AS，且需要3.0版本以上。Android Studio中需要安装Flutter Plugin，Dart Plugin两个插件。 Dart SDK也需要手动安装，直接下载zip包免安装。 成功准备好IDE环境之后，就可以创建Flutter Project了，默认创建Flutter Application就可以了，按照IDE创建提示一直到最终完成。 需要注意：同样由于网络环境，直接运行Flutter Project是不可行的，UI会一直停留在Gradle正在初始化工程。这时需要修改build.gradle配置中的中央Maven库到一个可信赖的公共Maven库。 这里我修改成Ali的Maven库 buildscript { ext.kotlin_version = &apos;1.1.51&apos; repositories { maven { url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; } google() } // ...... } // ...... allprojects { repositories { maven { url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; } } google() } // ...... 然后再次sync工程，进行运行。 首个创建的Flutter Project工程结构如下： 再来看看运行效果： 至此，Flutter，Dart环境均准备结束了。]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter简述]]></title>
    <url>%2F2018%2F03%2F12%2Fflutter%2Fflutter-introduction%2F</url>
    <content type="text"><![CDATA[Flutter是Google移动UI框架，用以创建高质量的native接口，真正跨平台，同时在iOS和Android上运行。Flutter是免费开源的，全球开发者及组织均可以使用。 Flutter有又几个特点： 快速开发 毫秒级别的加载速度，快速的渲染启动。 极具表现力，灵活的UI 接近native用户体验的特性。分层结构更是允许完全，从而可以非常快速的渲染且灵活。 native性能 Flutter组件包含所有主要平台的差异，例如滚动，导航，图标和字体，从而提供了在iOS和Android一样的native性能体验. 快速开发 Flutter热加载技术有助于你快速且简单地进行试验，构建UI，增加特性，并且快速修复bug。体验不到一秒的重新加载体验。 漂亮的UI Flutter内置MD设计风格及iOS组件，更有丰富的手势API，流畅的滚动体验和平台认同感会让用户感到愉悦。 查看组件 现代的响应式框架（Modern，reactive framework） 利用Flutter响应式框架和丰富的平台，布局和功能组件是的UI构建非常简单。使用灵活并且强大的API（2D，动画，手势，性能等）可以解决在UI上各种问题。 12345678910111213141516171819202122232425262728class CounterState extends State&lt;Counter&gt; &#123; int counter = 0; void increment() &#123; // Tells the Flutter framework that state has changed, // so the framework can run build() and update the display. setState(() &#123; counter++; &#125;); &#125; Widget build(BuildContext context) &#123; // This method is rerun every time setState is called. // The Flutter framework has been optimized to make rerunning // build methods fast, so that you can just rebuild anything that // needs updating rather than having to individually change // instances of widgets. return new Row( children: &lt;Widget&gt;[ new RaisedButton( onPressed: increment, child: new Text('Increment'), ), new Text('Count: $counter'), ], ); &#125;&#125; 查看组件及学习更多有关reactive framework 访问native特性和SDKs 通过使用平台APIs，第三方SDK和native代码，可以灵活地实现App。Flutter可以让你在iOS和Android上复用Java，Swift和Objective-C代码以及访问native特性和SDKs。 Flutter平台特性访问十分简单。下边是Flutter内interop example]示例： 123456789101112Future&lt;Null&gt; getBatteryLevel() async &#123; var batteryLevel = 'unknown'; try &#123; int result = await methodChannel.invokeMethod('getBatteryLevel'); batteryLevel = 'Battery level: $result%'; &#125; on PlatformException &#123; batteryLevel = 'Failed to get battery level.'; &#125; setState(() &#123; _batteryLevel = batteryLevel; &#125;);&#125; 学习如何使用packages，或者platform channels来访问native代码，APIs及SDKs。 统一的开发标准 Flutter拥有工具及库帮助你简单快速地在iOS和Android上实现你的想法。若你还没有任何移动开发经验，那么Flutter将会是你构建漂亮的移动APP的一种简单快速的额方式。若你是有经验的iOS或者Android开发人员，那么你可以使用Flutter组件，并且继续使用已有的Java/Objective-C/Swift程序。 构建 漂亮的APP UI 丰富的2D GPU加速APIs 响应式框架 动画/动作 APIs 兼容Android Material组件及苹果组件样式 流程的编码体验 急速热加载技术 IntelliJ：重构，自动补足功能等 Dart语言及核心库 包管理 拥有App所有特性 与移动OS APIs&amp;SDKs互操作性 Maven/Java Cocoapods/ObjC/Swift 优化 测试 Unit测试 继承测试 无设备测试 Debug IDE debug 基于网络debug 异步/唤醒感知 表达式求值程序 配置 时间线 CPU和内存 应用性能图标 部署 编译 Native ARM程序 消除无效代码 发布 App市场 Play Store 可以在技术概览了解更多Flutter的特殊性。 原文地址]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离线下载Android SDK（100%成功）]]></title>
    <url>%2F2017%2F10%2F30%2Fhow-to-download-android-sdk-offline%2F</url>
    <content type="text"><![CDATA[最近想在自己的电脑上搭建android开发环境了，由于电脑上很干净（没有任何开发环境），也就是从零开始，虽然知道sdk下载地址被墙了（那个墙很坑爹，好的资源都被墙）。 这里说的方法并非打开sdk-manager.exe的方式，因为这种方式只在android-sdk_r24.4.1-windows.zip之后就不再更新相同的方式了，算是里程碑了。再后边的版本只有一个tools文件夹了，换了文件格式，在windows下没有sdk-manager.exe了。也不是打开Android Studio的settings里边的Android SDK项就可以更新了，因为更新地址被墙了。。。。。。。。即使打开了代理也未必成功！！！ 下面说的方式有点儿傻瓜式，但肯定能成功，这个方法还不能成功，那就是人品问题了。 开始吧！！！！！ 首先下载最新的Android Studio，因为官网提供的Android Studio内不包含SDK环境，所以同时需要下载SKD Tools 第二打开Android Studio，进入Settings -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK 选项卡，首先设置SDK路径，即下载的SDK Tools路径，如下：按照顺序设置结束。 在选择SDK Update Sites。查看图中红框中的Android Repository。 将地址复制出来，https://dl.google.com/android/repository/repository2-1.xml，改地址在不同版本发布时可能有所不同，在浏览器中打开xml文件（应该是需要翻墙的），如下图：文件内数据太多，太大，往下拉，可以从打开的文档中可以看到，所有sdk配置，包含了tools，platform-tools等zip文件文件名（早起版本中提供了完整的下载地址），24版本之后就没有提供完整地址了。 将https://dl.google.com/android/repository/ + “需要的zip文件名”拼接在一起，粘贴到浏览器地址栏中，或者打开迅雷的等下载工具可以直接下载。 这种方式很傻瓜式，有些笨，但100%可以成功，且现在的网络速度很快，相信花不了多少时间就可以完成整个SDK的下载。 在网上最多的还是 找到国内镜像地址进行配置更新，但这种方法还需要看服务器内数据是否是最新的，很可能更新不及时。 通过ping dl.google.com来找到相关的服务器的方式，但这种方式缺陷是可能找到的海外服务器地址，一个都没法使用。 所以现在的这个方式是最靠谱的。程序员也可以自己写段程序处理xml文件，输出所有的下载地址，然后在迅雷中批量下载！！！！OK了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>sdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trap3——Fragment中定制ActionBar（同一个Activity内多个Fragment）]]></title>
    <url>%2F2017%2F10%2F11%2FTrap-Of-Customizing-ActionBar-in-Fragment%2F</url>
    <content type="text"><![CDATA[在最新的design提供了ToolBar来更加自由地定制，使用ActionBar，在布局文件中可以更加灵活地使用。 项目中实际遇上，首页三个tab页面内，ActionBar样式，功能均不同。ViewPager内不同的Fragment，需求的样式不同，菜单功能不同。 但处于同一个Activity内，一般情况下，一个Activity内只布局一个ActionBar（ToolBar）即可，但出于灵活布局，减少Fragment，Activity之间依赖，考虑在每个Fragment内均布局一个ActionBar（ToolBar），在Fragment内通过与原有ActionBar相同的调用来设置Activity对ActionBar的支持及相关属性设置。 @BindView(R.id.my_toolbar) Toolbar mActionBar; ((AppCompatActivity) getActivity()).setSupportActionBar(mActionBar); ActionBar actionBar = ((AppCompatActivity) getActivity()).getSupportActionBar(); if (actionBar == null) { return; } actionBar.setDisplayShowTitleEnabled(false); actionBar.setDisplayShowCustomEnabled(true); actionBar.setDisplayShowHomeEnabled(false); actionBar.setDisplayUseLogoEnabled(false); actionBar.setDisplayHomeAsUpEnabled(false); 这样就实现了在Fragment中实现Activity对ActionBar的显示及相关定制。 但此处为解决的问题是，在三个Fragment中均设置了ActionBar，在对应Fragment显示的时候，除了首个ActionBar正确，其他Fragment的ActionBar均不正确。 尚待解决。。。。。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Trap</tag>
        <tag>ActionBar</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trap2——Fragment中嵌有ViewPager（FragmentPagerAdapter）]]></title>
    <url>%2F2017%2F10%2F11%2FTrap-of-ViewPager-in-Fragment%2F</url>
    <content type="text"><![CDATA[项目需求中，需要实现app首页下部有三个tab，首个tab内部又有多个顶部tab效果。 首先考虑的是外部容器三个页面使用Fragment实现，首个tab内部又有多个tab对应的页面，即fragment。实现考虑使用ViewPager+TabLayout方式实现。 实现中问题： app每次打开，ViewPager首次加载显示正常，在切换之后再返回ViewPager，会发现tab页面消失。 原因：ViewPager内放置Fragment使用FragmentPagerAdapter时，传入的FragmentManager对象有问题。创建FragmentPagerAdapter时，代码如下： new HomeFragmentAdapter(mActivity.getSupportedFragmentManager(), fragments); 需要注意，此刻创建FragmentPagerAdapter本身是在一个Fragment中创建的，即在Fragment使用FragmentPagerAdapter，所以造成了上述情况。 解决方法：创建FragmentPagerAdapter时传入ChildFragmentManager对象，即使用容器Fragment来获取ChildFragmentManager对象。 new HomeFragmentAdapter(Fragment.getChildFragmentManager(), fragments); 这样可以解决这个问题。 在打开app后，home返回桌面，使用360等工具查杀后再打开，Fragment状态错乱 在app被查杀时，Fragment等组件保存的页面状态只是部分信息，不会将页面内所有数据类似快照一样保存完整，因此再次打开app时，页面内部数据恢复，其他部分无法恢复，造成显示错乱。 目前解决办法：在每次打开app时，将Fragment原先保存在保存在状态清除，恢复最初状态。在super.onCreate(savedInstanceState );之前调用。 // 再利用三方软件回收，查杀进程后，删除activity中fragment包含的状态 if (savedInstanceState != null) { String FRAGMENTS_TAG = &quot;android:support:fragments&quot;; savedInstanceState.remove(FRAGMENTS_TAG); } 这样可以解决在突然被查杀后，再次打开时显示错乱问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Trap</tag>
        <tag>Fragment</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trap1——在不同版本上使用FloatingActionButton]]></title>
    <url>%2F2017%2F08%2F30%2FTrap-Of-Using-FloatingActionButton-on-different-android%2F</url>
    <content type="text"><![CDATA[由于项目需求，要实现一个比较吸引人的交互设计。设计类似效果： 在实现前就考虑到design包内提供有一个FloatingActionButton组件可以来实现这个效果。FAB组件继承自ImageView，可以使用ImageView的所有属性。使用组件遇到问题： 组件内icon太小问题 除了layout_width， layout_height属性外，FAB又另外提供app:fabSize属性来设置FAB大小，且只支持此属性来改变FAB大小，其有”auto” “mini” “normal”三个属性值。 auto 基于窗口大小来确定FAB大小 mini FAB最小大小 normal FAB正常大小 尝试设置layout_width, layout_height来自定义FAB大小，同时设置fabSize属性，最终效果内，icon会被撑大或者看不到边缘，因此自定义width，height大小值来改变FAB大小是行不通的。 目前的方法是通过仅设置android:scaleType=“center”来避免系统在渲染时对icon进行大小改变操作（centerInside，centerCrop等属性存在icon大小改变情况）。 重写（override）normal，mini对应的dimen值，即fab_size_normal和fab_size_mini的值。 方法2暂未测试，却是可行的——dimens.xml &lt;resources&gt; &lt;dimen name=&quot;fab_size_normal&quot;&gt;100dp&lt;/dimen&gt; &lt;/resources&gt; 在引用是会引用到重写后的值。 PS：FAB组件需要配合CoordinatorLayout使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Trap</tag>
        <tag>Widget</tag>
        <tag>FloatingActionButton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android资源获取方式]]></title>
    <url>%2F2017%2F08%2F05%2Fandroid-v4-res-jotting%2F</url>
    <content type="text"><![CDATA[Android v4包已经更新过多个版本，在不同版本也新增加诸多新API，方便了开发人员的使用，这里要说的是针对资源获取的新API。新API给予了开发人员很大的方便，无须再像以前一样判断版本号，使用不同的方式去调用。 ContextCompat 完整限定名：android.support.v4.content.ContextCompat此类是Context的帮助类，在API 22（即5.0【LOLLIPOP_MR1】）中添加，其中提供诸多静态方法以方便调用。 此间我关注的是资源的获取方法： static final int getColor (Context context, int id)此方法在6.0（M）时添加，获取对应id的颜色资源。此方法返回的是带有系统主题风格的颜色。 static final Drawable getDrawable (Context context, int id) 此方法在5.0添加，获取id对应的Drawable可绘制对象。 ResourcesCompat 完整的限定名： android.support.v4.content.res.ResourcesCompat此类是Resources的帮助类。此类中获取资源的所返回的资源可以是与系统主题风格无关的资源。 static int getColor (Resources res, int id, Resources.Theme theme)同样获取颜色值，但其theme参数可以传入null，即不与当前Context主题相关。 static Drawable getDrawable (Resources res, int id, Resources.Theme theme)此方法获取可绘制Drawable资源。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取运行进程解决方案分析]]></title>
    <url>%2F2017%2F06%2F08%2Fget-running-processes-above-android-lollipop%2F</url>
    <content type="text"><![CDATA[在Android中获取运行进程这种需求在许多场合需要被使用到，但实际情况是在Android Lollipop即5.0后，Google开始收紧对底层权限控制。下面就涉及的方法及我现在找到的解决方案来分析下，是如何解决这个问题的。 可以从原有的几个方法的API变化及调用返回看出。 getRunningAppProcesses()在直到4.x， 5.0版本上工作良好（即便API中提示此方法仅用于debugging及编译管理UI之用），但从5.0+开始在一些OEM的系统中调用此方法进行测试会发现方法返回null。 getRunningTasks (int)方法从5.0起正式被标记为deprecated（过时）。5.0+版本上的第三方应用无法在引用此方法。原因在于调用者可能利用此方法获取的私人信息，导致信息泄露。而为了向后兼容，在原有的版本中依然可以获取到至少调用应用本身的task信息及部分其他不敏感的信息。 从上述两个方法的变化可以看出在5.0+之后，想要获取运行进程越来越难。 在5.0~6.0版本上，利用此处的解决方法还可以获取当前运行的进程列表。AndroidProcesses方案可以获取当前的运行进程列表。 这里的入口方法最常使用的是AndroidProcesses类的getRunningProcesses()。 在查看到具体实现后，就可以知道，这个解决方案一般的android开发人员是真想不到的，因为涉及到linux的文件系统，只有真正熟悉linux内核了解linux filesystem的开发人员才能想到此种办法。 这里主要涉及到文件系统中/proc目录。/proc文件系统目录是一个伪文件系统，它只存在内存当中，而不占用外存空间。它是在系统运行时产生于内存当中。linux通过这一伪文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。 /proc目录下有这诸多的文件和目录 在/proc目录下，进程名均是以数字命名的目录。因此获取运行进程信息，即是访问数字命名的目录，通过读取目录内特定文件来获取对应的进程名。 读取进程名分成以下几步： 读取进程目录下cmdline文件内容，android系统中该文件内包含的既是文件名。通过ps命令可以查看到当前android中的进程。然后再cat文件内容查看： cmdline内容也可能是空，具体原因不明。此种情况下，换做去读取/proc/pid/stat文件。stat内容格式：内容是空格分割的多列，其中第二列既是当前进程的进程名。 以步骤1、2访问/proc目录内所有数字命名目录， 即可以获取到当前Android系统中正在运行的进程。 在获取进程之后，我们就可以根据需要进行某些操作了。 据说google在7.0上有加强了对/proc目录访问的控制，AndroidProcesses的解决方案就有问题了…….. 持续关注此问题后续可能的解决方案中……]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建个人微博——手把手教]]></title>
    <url>%2F2017%2F06%2F01%2Fhow-to-setup-personal-blog-width-hexo-and-github%2F</url>
    <content type="text"><![CDATA[文章有点儿长，不过解释很清晰，有兴趣的朋友请耐心看完，肯定能搭建成功！^_^ 这里因为使用的是windows系统，所以选择了Hexo这个微博框架。 原来想使用与GitHub结合更有优势的jekyll，但是由于系统的问题，就放弃了。下来就如何来搭建吧！！！ 先说说怎么会想到搭建个人微博 工作多年，没有认真整理过自己工作中的经验，遇到的问题及解决方案。因此想着认真整理下过去到现在过程中的问题。废话不多说，下来看看我是如何来搭建我的个人微博的。 前提条件 需要有个github账号。一般做为一个开发人员，github肯定是访问过的，相信绝大多数开发人员会注册拥有一个github账号，因为这是全球知名的代码托管网站。全世界均可访问到它。若还没有可以到Github注册。 基本软件NodeJS，Git，Hexo在机子上需要使用到NodeJS进行部署，安装插件等。下载NodeJs。安装Git，进入Git下载页面选择合适的版本进行下载。如果不清楚Hexo是什么？？她是一个快速，简介，高效的博客框架。更多详情可以到Hexo官网读下这个文档就知道了。O(∩_∩)O哈哈~ 安装完成Git及NodeJs后，那么就可以开始准备安装Hexo了。打开GitBash，使用npm命令来安装Hexo程序。 回车，等待安装，安装完成后有如下信息：…….. 这样表示Hexo安装成功了。到此，搭建个人微博需要的3个软件就安装完成了。 接下来就需要进行相关配置及插件安装了。所有的操作均在GitBash命令行中进行操作。 建站 首先简历一个简单的站，创建初始化一个简单的文件夹。 $ hexo init myGitPages $ cd myGitPages $ npm install 这样就可以新建所需要的文件。安装完成后，可以看到如下的几个主要文件。 其中:_config.xml 可以配置网站信息。可以参考配置package.json 应用程序信息。有默认配置一些组件，可以自己根据需要添加或者移除。scaffolds 模板文件夹。当新建文章时，Hexo会根据scaffold来建立文件。source 资源文件夹，存放用户资源的地方。themes 主题文件夹。Hexo会根据主题来生成静态页面。 主题 Hexo可以有很多主题，在Github首页搜索框内输入”hexo theme”，可以搜索到很多主题，目前我使用的是litten的yilia主题。 可以在进入到建立的站点文件夹下（我的是myGitPages）下，下载yilia主题 $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载完成后，打开站点个目录下（myGitPages）的_config.xml文件，修改其中的theme属性成 theme: yilia 这样就可以在发布文章的手看到修改的主题，或者通过hexo server进行查看。 发布 发布文章前一定要确认已经安装了hexo-deployer-git插件，否则无法正常发文章到git上的。 $ npm install hexo-deployer-git --save 来安装git插件。 到目前基本上需要的从博客站点建立，到发布所需要的软件准备工作都就绪了。 PS：yilia要显示所有文章还需要进行一个配置，下文会写到。 在开始写文章发布之前可以，先查本地运行查看Hexo运行情况，运行 $ hexo server 启动服务器。默认情况下，端口地址是4000。打开浏览器，访问：http://localhost:4000查看效果。若访问出错，没有打开页面，那么可能是端口被占用导致。此时可以使用 $ hexo server -p 5000 修改端口，然后重新输入端口号进行查看。若访问成功，默认看到的是hello-wold.md（即source/_post文件夹下的默认创建文件）文件发布后的效果。 准备工作结束，可以开始写文章发布 上述工作都结束后，可以进入到站点文件夹/source/_post/目录下新建md文件，使用Markdown标记语言写一些内容。 Markdown标记语言使用比较简单，可以在这里学习简单的使用，或者markdown.cn学习使用。 在写完文章之后就需要将写的文章部署到GitHub上去了。来看下这个过程。 由于要发布博客到GitHub实际上使用了GitHub Pages功能，因此可以到这里来查看相关的介绍。其中详细介绍了Pages概念，及如何建立自己的站点。 一下先简绍下我自己的建立过程。 建立GitHub仓库 建立仓库，用以部署Hexo生成的博客。如果还没有GitHub账号就需要注册了。有GitHub账号的小伙伴可以到Github网站创建一个新仓库，如下显示。 其中仓库名有所讲究，它必须是username.github.io ，这里的username有两种情况，其一是你的用户名即注册时使用的名称，其二是组织名称（此处组织名称并未尝试）。如下图可以看下位置。 Hexo发布前需要配置_config.xml 在使用Hexo发布博客之前，当然还需要让Hexo知道要发布到什么地方。 在站点根目录下（myGitPages），找到并编辑_config.xml文件，如下部分： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:techinsight/techinsight.github.io.git branch: master message: 将新建的仓库信息及分支信息配置到_config.xml，让Hexo知道部署到GitHub的那个仓库。 发布 最后，就需要发布了。可以在站点根目录下（myGitPages）下运行一下命令： $ hexo clean #清除原有生成的相关文件 $ hexo generate #重新生成静态页面 $ hexo deploy #进行部署 在运行部署命令时，会弹出ssh密码输入确认框，输入username.github.io仓库密码，点击OK即可进行顺利发布。 然后就去访问你的个人站点吧。你会看到发布的文章。 PS: 不同的主题可能在主题中还需要进行一定的配置，这个看个人喜好使用哪个主题，我使用的是yilia主题，其在初次查看所有文章时会发现展示的不是文章列表。那么按照主题作者提示进行配置后，重新部署就可以了。 nodejs版本大于6.2（最新的nodejs肯定符合）。 在博客根目录下（不是yilia根目录下）执行如下命令： npm i hexo-generator-json-content –save 在根目录_config.xml文件内配置： &nbsp;&nbsp;&nbsp;&nbsp;# 查看yilia主题下所有文章配置 &nbsp;&nbsp;&nbsp;&nbsp;jsonContent: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meta: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pages: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; posts: &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; title: true &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; date: true &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; path: true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slug: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; updated: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comments: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; permalink: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excerpt: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tags: true]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>微博</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多进程app中Application回调onCreate()方法被执行多次分析及解决]]></title>
    <url>%2F2017%2F05%2F28%2Fandroid-multiprocess-oncreate-executed-serval-times%2F</url>
    <content type="text"><![CDATA[问题描述 最近工作中碰到一个问题，在优化app，使用DDMS查看Application log过程中看到，app启动了三个进程，一个主进程，两个附带的进程。如下图可看到一个app启动的三个进程。 自定义Application回调方法onCreate()被执行了3次。开始不知是何原因。 相关知识 android:process 从Android开发者文档中的manifest中进程配置android:process可以获知:正常情况下，应用程序的所有组件运行在一个默认的进程名下，因此不需要使用这个属性。但在需要的情况下，可以通过使用这个属性来覆盖默认进程，这样一个app就跨越多个进程。 如果这个属性值以冒号（“:”）开始，说明新进程相对于应用程序是一个私有进程，且组件运行在此进程中。若属性值以小写字符开始，那么新进程即是一个全局进程，组件运行在这个全局进程中。这也意味着其他应用程序组件可以与此进程进行通信，减少资源使用。 标签&lt;application&gt;的android:process属性可以为整个app内组件设置一个默认的运行进程。 manifest中组件标签&lt;activity&gt;， &lt;service&gt;， &lt;provider&gt;, &lt;receiver&gt;都支持配置android:process，即每个组件均可以创建运行在自己的一个新进程中。 Application类 我们可以自定义继承Application类来实现自己的Application，然后在其中的onCreate()方法中进行一定的初始化工作。 若自定义了Application类，那么需要注意的就是这个类在当app中有多个进程时，每个进程启动时都会初始化一次Application。在Android中很不幸的就是我们无法为每个新创建的进程来分别创建一个Application类。 解决方案 第一：getRunningAppProcesses() 每个进程对应一个application，这样可以通过针对特定进程名，进行相应的初始化工作，避免资源浪费，执行时间消耗。 因为Application的执行时间影响着首个activity，service等的启动时间。即Application执行时间越长，首个组件（activity）启动时间越晚，给用户造成的感觉就是应用启动速度特别慢。 可以看出，Application回调方法onCreate()被执行3次，均执行耗时操作，这样造成了在点击应用logo后，到看到进入app，首个页面（Activity）启动，耗时将近6s，外加处理器速度，在较慢的机器上，这个时间可能更长，甚至超过10s。 目前较多采用的方法既是所提到的根据具体进程来进行相应的初始化工作，核心的获取对应进程的方法如下： /** * 获取进程名。 * 由于app是一个多进程应用，因此每个进程被os创建时， * onCreate()方法均会被执行一次， * 进行辨别初始化，针对特定进程进行相应初始化工作， * 此方法可以提高一半启动时间。 * * @param context 上下文环境对象 * * @return 获取此进程的进程名 */ private String getProcessName(Context context) { ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcesses = am.getRunningAppProcesses(); if (runningAppProcesses == null) { return &quot;&quot;; } for (ActivityManager.RunningAppProcessInfo runningAppProcess : runningAppProcesses) { if (runningAppProcess.pid == android.os.Process.myPid() &amp;&amp; !TextUtils.isEmpty(runningAppProcess.processName)) { return runningAppProcess.processName; } } return &quot;&quot;; } 这样经过测试，在不同的进程被创建时，进行不同的工作，执行时间可以缩短一半。 虽然这种方法在某些版本上可以奏效，在但Android 5.0+版本中，由于Google开始收紧对Android底层权限管理，在趋势上方法getRunningAppProcesses())将会被毙掉。因为已经在一些版本的环境中，此方法返回null。 第二：UsageStatsManager 使用类UsageStatsManager来获取运行的apps列表，但是使用这个类需要添加一个权限PACKAGE_USAGE_STATS，而此权限是系统权限，要使用必须到Settings应用中去针对应用进行授权（我们的app用户肯定不会愿意多次一步）。另外，据称有些OEM厂商已经删除了此项设置，换言之在Settings中找不到授权入口。 因此这个途径也就被毙掉了。 最终方案 经过几天google方案及针对可能的解决方法进行测试，下边的这个感觉比较靠谱。 这是一个开源项目，项目地址点击这里。 在我们的Application中集成并测试了该方法。 源码中添加一个方法，类似于使用getRunningAppProcesses()方法一样： 以下是在三个不同的Android版本进行测试结果： 可以看到，针对这三个版本是可以达到相关初始化代码只执行一次的效果。这样可以缩短启动消耗的时间。 更多版本类型测试大家可以自行进行测试。 时间原因，此方案的代码及解决方法还没有来得及跟踪，有时间在做分析…… 这种方案也有限制： 一些版本的系统应用不包括在内，因为他们具有更高级别的SElinux context； 这种方法也不是getRunningAppProcesses())完全的替代，因为它无法给出集成的pkgList，lru和importance信息； 此库在7.0开发者预览版本上是无法起作用的。 下面的一篇文章就来分析下此方案是如何解决读取进程的——&gt;《Android获取运行进程解决方案分析》]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Application</tag>
        <tag>多进程</tag>
      </tags>
  </entry>
</search>
