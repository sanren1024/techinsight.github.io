<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Flutter简述]]></title>
    <url>%2F2018%2F03%2F23%2FFlutter%2FFlutter_Introduction%2F</url>
    <content type="text"><![CDATA[Flutter是Google移动UI框架，用以创建高质量的native接口，真正跨平台，同时在iOS和Android上运行。Flutter是免费开源的，全球开发者及组织均可以使用。 Flutter有又几个特点： 快速开发 毫秒级别的加载速度，快速的渲染启动。 极具表现力，灵活的UI 接近native用户体验的特性。分层结构更是允许完全，从而可以非常快速的渲染且灵活。 native性能 Flutter组件包含所有主要平台的差异，例如滚动，导航，图标和字体，从而提供了在iOS和Android一样的native性能体验. 快速开发 Flutter热加载技术有助于你快速且简单地进行试验，构建UI，增加特性，并且快速修复bug。体验不到一秒的重新加载体验。 漂亮的UI Flutter内置MD设计风格及iOS组件，更有丰富的手势API，流畅的滚动体验和平台认同感会让用户感到愉悦。 查看组件 现代的响应式框架（Modern，reactive framework） 利用Flutter响应式框架和丰富的平台，布局和功能组件是的UI构建非常简单。使用灵活并且强大的API（2D，动画，手势，性能等）可以解决在UI上各种问题。 class CounterState extends State&lt;Counter&gt; { int counter = 0; void increment() { // Tells the Flutter framework that state has changed, // so the framework can run build() and update the display. setState(() { counter++; }); } Widget build(BuildContext context) { // This method is rerun every time setState is called. // The Flutter framework has been optimized to make rerunning // build methods fast, so that you can just rebuild anything that // needs updating rather than having to individually change // instances of widgets. return new Row( children: &lt;Widget&gt;[ new RaisedButton( onPressed: increment, child: new Text(&#39;Increment&#39;), ), new Text(&#39;Count: $counter&#39;), ], ); }} 查看组件及学习更多有关reactive framework]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter(一) 环境准备]]></title>
    <url>%2F2018%2F03%2F15%2FFlutter%2FFlutter-Install%2F</url>
    <content type="text"><![CDATA[安装Flutter 在国内安装使用Flutter，首先阅读下这篇文章，由于国内网络大环境问题，需要提前进行一点配置。 在国内安装Flutter需要首先需要一个值得信任的国内镜像。在镜像上边保存着Flutter需要的依赖及相关库，包等。为了使用Flutter，需要使用一个备用存储位置，我们需要配置环境变量。配置环境变量名：PUB_HOSTED_URL和FLUTTER_STORAGE_BASE_URL。 在windows系统中，需要在环境变量设置中添加：PUB_HOSTED_URL ： https://pub.flutter-io.cnFLUTTER_STORAGE_BASE_URL ： https://storage.flutter-io.cn 然后运行Git命令（前提是安装了GitBash工具）：git clone -b dev https://github.com/flutter/flutter.git Flutter Flutter文件夹需要注意：文件夹存放的路径上不要出现空格，否则在IDE中进行工程创建后会有警告，SDK环境路径上存在分隔符。在clone完成之后，即flutter sdk下载完毕，还需要配置Flutter环境： xxxx/Flutter/bin目录下。 重新打开一个命令行，在其中输入命令 flutter doctor 进行环境及缺失的依赖检查，并下载需要的依赖。运行效果如下图： 在环境及相关依赖检查完成之后，可以开始在Android Studio中进行创建工程行为。 注意：Android Studio 预览版中无法保证运行Flutter成功。因此需要使用稳定版AS，且需要3.0版本以上。Android Studio中需要安装Flutter Plugin，Dart Plugin两个插件。 Dart SDK也需要手动安装，直接下载zip包免安装。 成功准备好IDE环境之后，就可以创建Flutter Project了，默认创建Flutter Application就可以了，按照IDE创建提示一直到最终完成。 需要注意：同样由于网络环境，直接运行Flutter Project是不可行的，UI会一直停留在Gradle正在初始化工程。这时需要修改build.gradle配置中的中央Maven库到一个可信赖的公共Maven库。 这里我修改成Ali的Maven库 buildscript { ext.kotlin_version = &apos;1.1.51&apos; repositories { maven { url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; } google() } // ...... } // ...... allprojects { repositories { maven { url &apos;http://maven.aliyun.com/nexus/content/groups/public/&apos; } } google() } // ...... 然后再次sync工程，进行运行。 首个创建的Flutter Project工程结构如下： 再来看看运行效果： 至此，Flutter，Dart环境均准备结束了。]]></content>
      <categories>
        <category>Android</category>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
        <tag>Android</tag>
        <tag>Dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[离线下载Android SDK（100%成功）]]></title>
    <url>%2F2017%2F10%2F30%2Fhow-to-download-android-sdk-offline%2F</url>
    <content type="text"><![CDATA[最近想在自己的电脑上搭建android开发环境了，由于电脑上很干净（没有任何开发环境），也就是从零开始，虽然知道sdk下载地址被墙了（那个墙很坑爹，好的资源都被墙）。 这里说的方法并非打开sdk-manager.exe的方式，因为这种方式只在android-sdk_r24.4.1-windows.zip之后就不再更新相同的方式了，算是里程碑了。再后边的版本只有一个tools文件夹了，换了文件格式，在windows下没有sdk-manager.exe了。也不是打开Android Studio的settings里边的Android SDK项就可以更新了，因为更新地址被墙了。。。。。。。。即使打开了代理也未必成功！！！下面说的方式有点儿傻瓜式，但肯定能成功，这个方法还不能成功，那就是人品问题了。 开始吧！！！！！ 首先下载最新的Android Studio，因为官网提供的Android Studio内不包含SDK环境，所以同时需要下载SKD Tools 第二打开Android Studio，进入Settings -&gt; Appearance &amp; Behavior -&gt; System Settings -&gt; Android SDK 选项卡，首先设置SDK路径，即下载的SDK Tools路径，如下：按照顺序设置结束。 在选择SDK Update Sites。查看图中红框中的Android Repository。 将地址复制出来，https://dl.google.com/android/repository/repository2-1.xml，改地址在不同版本发布时可能有所不同，在浏览器中打开xml文件（应该是需要翻墙的），如下图：文件内数据太多，太大，往下拉，可以从打开的文档中可以看到，所有sdk配置，包含了tools，platform-tools等zip文件文件名（早起版本中提供了完整的下载地址），24版本之后就没有提供完整地址了。 将https://dl.google.com/android/repository/ + “需要的zip文件名”拼接在一起，粘贴到浏览器地址栏中，或者打开迅雷的等下载工具可以直接下载。 这种方式很傻瓜式，有些笨，但100%可以成功，且现在的网络速度很快，相信花不了多少时间就可以完成整个SDK的下载。 在网上最多的还是 找到国内镜像地址进行配置更新，但这种方法还需要看服务器内数据是否是最新的，很可能更新不及时。 通过ping dl.google.com来找到相关的服务器的方式，但这种方式缺陷是可能找到的海外服务器地址，一个都没法使用。 所以现在的这个方式是最靠谱的。程序员也可以自己写段程序处理xml文件，输出所有的下载地址，然后在迅雷中批量下载！！！！OK了]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>sdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trap3——Fragment中定制ActionBar（同一个Activity内多个Fragment）]]></title>
    <url>%2F2017%2F10%2F11%2FTrap-Of-Customizing-ActionBar-in-Fragment%2F</url>
    <content type="text"><![CDATA[在最新的design提供了ToolBar来更加自由地定制，使用ActionBar，在布局文件中可以更加灵活地使用。 项目中实际遇上，首页三个tab页面内，ActionBar样式，功能均不同。ViewPager内不同的Fragment，需求的样式不同，菜单功能不同。 但处于同一个Activity内，一般情况下，一个Activity内只布局一个ActionBar（ToolBar）即可，但出于灵活布局，减少Fragment，Activity之间依赖，考虑在每个Fragment内均布局一个ActionBar（ToolBar），在Fragment内通过与原有ActionBar相同的调用来设置Activity对ActionBar的支持及相关属性设置。 @BindView(R.id.my_toolbar) Toolbar mActionBar; ((AppCompatActivity) getActivity()).setSupportActionBar(mActionBar); ActionBar actionBar = ((AppCompatActivity) getActivity()).getSupportActionBar(); if (actionBar == null) { return; } actionBar.setDisplayShowTitleEnabled(false); actionBar.setDisplayShowCustomEnabled(true); actionBar.setDisplayShowHomeEnabled(false); actionBar.setDisplayUseLogoEnabled(false); actionBar.setDisplayHomeAsUpEnabled(false); 这样就实现了在Fragment中实现Activity对ActionBar的显示及相关定制。 但此处为解决的问题是，在三个Fragment中均设置了ActionBar，在对应Fragment显示的时候，除了首个ActionBar正确，其他Fragment的ActionBar均不正确。 尚待解决。。。。。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Trap</tag>
        <tag>ActionBar</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trap2——Fragment中嵌有ViewPager（FragmentPagerAdapter）]]></title>
    <url>%2F2017%2F10%2F11%2FTrap-of-ViewPager-in-Fragment%2F</url>
    <content type="text"><![CDATA[项目需求中，需要实现app首页下部有三个tab，首个tab内部又有多个顶部tab效果。 首先考虑的是外部容器三个页面使用Fragment实现，首个tab内部又有多个tab对应的页面，即fragment。实现考虑使用ViewPager+TabLayout方式实现。 实现中问题： app每次打开，ViewPager首次加载显示正常，在切换之后再返回ViewPager，会发现tab页面消失。 原因：ViewPager内放置Fragment使用FragmentPagerAdapter时，传入的FragmentManager对象有问题。创建FragmentPagerAdapter时，代码如下： new HomeFragmentAdapter(mActivity.getSupportedFragmentManager(), fragments); 需要注意，此刻创建FragmentPagerAdapter本身是在一个Fragment中创建的，即在Fragment使用FragmentPagerAdapter，所以造成了上述情况。 解决方法：创建FragmentPagerAdapter时传入ChildFragmentManager对象，即使用容器Fragment来获取ChildFragmentManager对象。 new HomeFragmentAdapter(Fragment.getChildFragmentManager(), fragments); 这样可以解决这个问题。 在打开app后，home返回桌面，使用360等工具查杀后再打开，Fragment状态错乱 在app被查杀时，Fragment等组件保存的页面状态只是部分信息，不会将页面内所有数据类似快照一样保存完整，因此再次打开app时，页面内部数据恢复，其他部分无法恢复，造成显示错乱。 目前解决办法：在每次打开app时，将Fragment原先保存在保存在状态清除，恢复最初状态。在super.onCreate(savedInstanceState );之前调用。 // 再利用三方软件回收，查杀进程后，删除activity中fragment包含的状态 if (savedInstanceState != null) { String FRAGMENTS_TAG = &quot;android:support:fragments&quot;; savedInstanceState.remove(FRAGMENTS_TAG); } 这样可以解决在突然被查杀后，再次打开时显示错乱问题。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Trap</tag>
        <tag>Fragment</tag>
        <tag>ViewPager</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trap1——在不同版本上使用FloatingActionButton]]></title>
    <url>%2F2017%2F08%2F30%2FTrap-Of-Using-FloatingActionButton-on-different-android%2F</url>
    <content type="text"><![CDATA[由于项目需求，要实现一个比较吸引人的交互设计。设计类似效果： 在实现前就考虑到design包内提供有一个FloatingActionButton组件可以来实现这个效果。FAB组件继承自ImageView，可以使用ImageView的所有属性。使用组件遇到问题： 组件内icon太小问题 除了layout_width， layout_height属性外，FAB又另外提供app:fabSize属性来设置FAB大小，且只支持此属性来改变FAB大小，其有”auto” “mini” “normal”三个属性值。 auto 基于窗口大小来确定FAB大小 mini FAB最小大小 normal FAB正常大小 尝试设置layout_width, layout_height来自定义FAB大小，同时设置fabSize属性，最终效果内，icon会被撑大或者看不到边缘，因此自定义width，height大小值来改变FAB大小是行不通的。 目前的方法是通过仅设置android:scaleType=“center”来避免系统在渲染时对icon进行大小改变操作（centerInside，centerCrop等属性存在icon大小改变情况）。 重写（override）normal，mini对应的dimen值，即fab_size_normal和fab_size_mini的值。 方法2暂未测试，却是可行的——dimens.xml &lt;resources&gt; &lt;dimen name=&quot;fab_size_normal&quot;&gt;100dp&lt;/dimen&gt; &lt;/resources&gt; 在引用是会引用到重写后的值。 PS：FAB组件需要配合CoordinatorLayout使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Trap</tag>
        <tag>Widget</tag>
        <tag>FloatingActionButton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android资源获取方式]]></title>
    <url>%2F2017%2F08%2F05%2Fandroid-v4-res-jotting%2F</url>
    <content type="text"><![CDATA[Android v4包已经更新过多个版本，在不同版本也新增加诸多新API，方便了开发人员的使用，这里要说的是针对资源获取的新API。新API给予了开发人员很大的方便，无须再像以前一样判断版本号，使用不同的方式去调用。 ContextCompat 完整限定名：android.support.v4.content.ContextCompat此类是Context的帮助类，在API 22（即5.0【LOLLIPOP_MR1】）中添加，其中提供诸多静态方法以方便调用。 此间我关注的是资源的获取方法： static final int getColor (Context context, int id)此方法在6.0（M）时添加，获取对应id的颜色资源。此方法返回的是带有系统主题风格的颜色。 static final Drawable getDrawable (Context context, int id) 此方法在5.0添加，获取id对应的Drawable可绘制对象。 ResourcesCompat 完整的限定名： android.support.v4.content.res.ResourcesCompat此类是Resources的帮助类。此类中获取资源的所返回的资源可以是与系统主题风格无关的资源。 static int getColor (Resources res, int id, Resources.Theme theme)同样获取颜色值，但其theme参数可以传入null，即不与当前Context主题相关。 static Drawable getDrawable (Resources res, int id, Resources.Theme theme)此方法获取可绘制Drawable资源。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>资源</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android获取运行进程解决方案分析]]></title>
    <url>%2F2017%2F06%2F08%2Fget-running-processes-above-android-lollipop%2F</url>
    <content type="text"><![CDATA[在Android中获取运行进程这种需求在许多场合需要被使用到，但实际情况是在Android Lollipop即5.0后，Google开始收紧对底层权限控制。下面就涉及的方法及我现在找到的解决方案来分析下，是如何解决这个问题的。 可以从原有的几个方法的API变化及调用返回看出。 getRunningAppProcesses()在直到4.x， 5.0版本上工作良好（即便API中提示此方法仅用于debugging及编译管理UI之用），但从5.0+开始在一些OEM的系统中调用此方法进行测试会发现方法返回null。 getRunningTasks (int)方法从5.0起正式被标记为deprecated（过时）。5.0+版本上的第三方应用无法在引用此方法。原因在于调用者可能利用此方法获取的私人信息，导致信息泄露。而为了向后兼容，在原有的版本中依然可以获取到至少调用应用本身的task信息及部分其他不敏感的信息。 从上述两个方法的变化可以看出在5.0+之后，想要获取运行进程越来越难。 在5.0~6.0版本上，利用此处的解决方法还可以获取当前运行的进程列表。AndroidProcesses方案可以获取当前的运行进程列表。 这里的入口方法最常使用的是AndroidProcesses类的getRunningProcesses()。 在查看到具体实现后，就可以知道，这个解决方案一般的android开发人员是真想不到的，因为涉及到linux的文件系统，只有真正熟悉linux内核了解linux filesystem的开发人员才能想到此种办法。 这里主要涉及到文件系统中/proc目录。/proc文件系统目录是一个伪文件系统，它只存在内存当中，而不占用外存空间。它是在系统运行时产生于内存当中。linux通过这一伪文件系统，在运行时访问内核内部数据结构、改变内核设置的机制。 /proc目录下有这诸多的文件和目录 在/proc目录下，进程名均是以数字命名的目录。因此获取运行进程信息，即是访问数字命名的目录，通过读取目录内特定文件来获取对应的进程名。 读取进程名分成以下几步： 读取进程目录下cmdline文件内容，android系统中该文件内包含的既是文件名。通过ps命令可以查看到当前android中的进程。然后再cat文件内容查看： cmdline内容也可能是空，具体原因不明。此种情况下，换做去读取/proc/pid/stat文件。stat内容格式：内容是空格分割的多列，其中第二列既是当前进程的进程名。 以步骤1、2访问/proc目录内所有数字命名目录， 即可以获取到当前Android系统中正在运行的进程。 在获取进程之后，我们就可以根据需要进行某些操作了。 据说google在7.0上有加强了对/proc目录访问的控制，AndroidProcesses的解决方案就有问题了…….. 持续关注此问题后续可能的解决方案中……]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>多进程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用hexo+github搭建个人微博——手把手教]]></title>
    <url>%2F2017%2F06%2F01%2Fhow-to-setup-personal-blog-width-hexo-and-github%2F</url>
    <content type="text"><![CDATA[文章有点儿长，不过解释很清晰，有兴趣的朋友请耐心看完，肯定能搭建成功！^_^ 这里因为使用的是windows系统，所以选择了Hexo这个微博框架。原来想使用与GitHub结合更有优势的jekyll，但是由于系统的问题，就放弃了。下来就如何来搭建吧！！！ 先说说怎么会想到搭建个人微博 工作多年，没有认真整理过自己工作中的经验，遇到的问题及解决方案。因此想着认真整理下过去到现在过程中的问题。废话不多说，下来看看我是如何来搭建我的个人微博的。 前提条件 需要有个github账号。一般做为一个开发人员，github肯定是访问过的，相信绝大多数开发人员会注册拥有一个github账号，因为这是全球知名的代码托管网站。全世界均可访问到它。若还没有可以到Github注册。 基本软件NodeJS，Git，Hexo在机子上需要使用到NodeJS进行部署，安装插件等。下载NodeJs。安装Git，进入Git下载页面选择合适的版本进行下载。如果不清楚Hexo是什么？？她是一个快速，简介，高效的博客框架。更多详情可以到Hexo官网读下这个文档就知道了。O(∩_∩)O哈哈~ 安装完成Git及NodeJs后，那么就可以开始准备安装Hexo了。打开GitBash，使用npm命令来安装Hexo程序。 回车，等待安装，安装完成后有如下信息：…….. 这样表示Hexo安装成功了。到此，搭建个人微博需要的3个软件就安装完成了。 接下来就需要进行相关配置及插件安装了。所有的操作均在GitBash命令行中进行操作。 建站 首先简历一个简单的站，创建初始化一个简单的文件夹。 $ hexo init myGitPages $ cd myGitPages $ npm install 这样就可以新建所需要的文件。安装完成后，可以看到如下的几个主要文件。 其中:_config.xml 可以配置网站信息。可以参考配置package.json 应用程序信息。有默认配置一些组件，可以自己根据需要添加或者移除。scaffolds 模板文件夹。当新建文章时，Hexo会根据scaffold来建立文件。source 资源文件夹，存放用户资源的地方。themes 主题文件夹。Hexo会根据主题来生成静态页面。 主题 Hexo可以有很多主题，在Github首页搜索框内输入”hexo theme”，可以搜索到很多主题，目前我使用的是litten的yilia主题。 可以在进入到建立的站点文件夹下（我的是myGitPages）下，下载yilia主题 $ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 下载完成后，打开站点个目录下（myGitPages）的_config.xml文件，修改其中的theme属性成 theme: yilia 这样就可以在发布文章的手看到修改的主题，或者通过hexo server进行查看。 发布 发布文章前一定要确认已经安装了hexo-deployer-git插件，否则无法正常发文章到git上的。 $ npm install hexo-deployer-git --save 来安装git插件。 到目前基本上需要的从博客站点建立，到发布所需要的软件准备工作都就绪了。 PS：yilia要显示所有文章还需要进行一个配置，下文会写到。 在开始写文章发布之前可以，先查本地运行查看Hexo运行情况，运行 $ hexo server 启动服务器。默认情况下，端口地址是4000。打开浏览器，访问：http://localhost:4000查看效果。若访问出错，没有打开页面，那么可能是端口被占用导致。此时可以使用 $ hexo server -p 5000 修改端口，然后重新输入端口号进行查看。若访问成功，默认看到的是hello-wold.md（即source/_post文件夹下的默认创建文件）文件发布后的效果。 准备工作结束，可以开始写文章发布 上述工作都结束后，可以进入到站点文件夹/source/_post/目录下新建md文件，使用Markdown标记语言写一些内容。 Markdown标记语言使用比较简单，可以在这里学习简单的使用，或者markdown.cn学习使用。 在写完文章之后就需要将写的文章部署到GitHub上去了。来看下这个过程。 由于要发布博客到GitHub实际上使用了GitHub Pages功能，因此可以到这里来查看相关的介绍。其中详细介绍了Pages概念，及如何建立自己的站点。 一下先简绍下我自己的建立过程。 建立GitHub仓库 建立仓库，用以部署Hexo生成的博客。如果还没有GitHub账号就需要注册了。有GitHub账号的小伙伴可以到Github网站创建一个新仓库，如下显示。 其中仓库名有所讲究，它必须是username.github.io ，这里的username有两种情况，其一是你的用户名即注册时使用的名称，其二是组织名称（此处组织名称并未尝试）。如下图可以看下位置。 Hexo发布前需要配置_config.xml 在使用Hexo发布博客之前，当然还需要让Hexo知道要发布到什么地方。 在站点根目录下（myGitPages），找到并编辑_config.xml文件，如下部分： # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repository: git@github.com:techinsight/techinsight.github.io.git branch: master message: 将新建的仓库信息及分支信息配置到_config.xml，让Hexo知道部署到GitHub的那个仓库。 发布 最后，就需要发布了。可以在站点根目录下（myGitPages）下运行一下命令： $ hexo clean #清除原有生成的相关文件 $ hexo generate #重新生成静态页面 $ hexo deploy #进行部署 在运行部署命令时，会弹出ssh密码输入确认框，输入username.github.io仓库密码，点击OK即可进行顺利发布。 然后就去访问你的个人站点吧。你会看到发布的文章。 PS: 不同的主题可能在主题中还需要进行一定的配置，这个看个人喜好使用哪个主题，我使用的是yilia主题，其在初次查看所有文章时会发现展示的不是文章列表。那么按照主题作者提示进行配置后，重新部署就可以了。 nodejs版本大于6.2（最新的nodejs肯定符合）。 在博客根目录下（不是yilia根目录下）执行如下命令： npm i hexo-generator-json-content –save 在根目录_config.xml文件内配置： &nbsp;&nbsp;&nbsp;&nbsp;# 查看yilia主题下所有文章配置 &nbsp;&nbsp;&nbsp;&nbsp;jsonContent: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; meta: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pages: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; posts: &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; title: true &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; date: true &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp; path: true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; text: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raw: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; content: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slug: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; updated: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; comments: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; link: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; permalink: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; excerpt: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; categories: false &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tags: true]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>微博</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android多进程app中Application回调onCreate()方法被执行多次分析及解决]]></title>
    <url>%2F2017%2F05%2F28%2Fandroid-multiprocess-oncreate-executed-serval-times%2F</url>
    <content type="text"><![CDATA[问题描述 最近工作中碰到一个问题，在优化app，使用DDMS查看Application log过程中看到，app启动了三个进程，一个主进程，两个附带的进程。如下图可看到一个app启动的三个进程。 自定义Application回调方法onCreate()被执行了3次。开始不知是何原因。 相关知识 android:process 从Android开发者文档中的manifest中进程配置android:process可以获知:正常情况下，应用程序的所有组件运行在一个默认的进程名下，因此不需要使用这个属性。但在需要的情况下，可以通过使用这个属性来覆盖默认进程，这样一个app就跨越多个进程。 如果这个属性值以冒号（“:”）开始，说明新进程相对于应用程序是一个私有进程，且组件运行在此进程中。若属性值以小写字符开始，那么新进程即是一个全局进程，组件运行在这个全局进程中。这也意味着其他应用程序组件可以与此进程进行通信，减少资源使用。 标签&lt;application&gt;的android:process属性可以为整个app内组件设置一个默认的运行进程。 manifest中组件标签&lt;activity&gt;， &lt;service&gt;， &lt;provider&gt;, &lt;receiver&gt;都支持配置android:process，即每个组件均可以创建运行在自己的一个新进程中。 Application类 我们可以自定义继承Application类来实现自己的Application，然后在其中的onCreate()方法中进行一定的初始化工作。 若自定义了Application类，那么需要注意的就是这个类在当app中有多个进程时，每个进程启动时都会初始化一次Application。在Android中很不幸的就是我们无法为每个新创建的进程来分别创建一个Application类。 解决方案 第一：getRunningAppProcesses() 每个进程对应一个application，这样可以通过针对特定进程名，进行相应的初始化工作，避免资源浪费，执行时间消耗。 因为Application的执行时间影响着首个activity，service等的启动时间。即Application执行时间越长，首个组件（activity）启动时间越晚，给用户造成的感觉就是应用启动速度特别慢。 可以看出，Application回调方法onCreate()被执行3次，均执行耗时操作，这样造成了在点击应用logo后，到看到进入app，首个页面（Activity）启动，耗时将近6s，外加处理器速度，在较慢的机器上，这个时间可能更长，甚至超过10s。 目前较多采用的方法既是所提到的根据具体进程来进行相应的初始化工作，核心的获取对应进程的方法如下： /** * 获取进程名。 * 由于app是一个多进程应用，因此每个进程被os创建时， * onCreate()方法均会被执行一次， * 进行辨别初始化，针对特定进程进行相应初始化工作， * 此方法可以提高一半启动时间。 * * @param context 上下文环境对象 * * @return 获取此进程的进程名 */ private String getProcessName(Context context) { ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppProcesses = am.getRunningAppProcesses(); if (runningAppProcesses == null) { return &quot;&quot;; } for (ActivityManager.RunningAppProcessInfo runningAppProcess : runningAppProcesses) { if (runningAppProcess.pid == android.os.Process.myPid() &amp;&amp; !TextUtils.isEmpty(runningAppProcess.processName)) { return runningAppProcess.processName; } } return &quot;&quot;; } 这样经过测试，在不同的进程被创建时，进行不同的工作，执行时间可以缩短一半。 虽然这种方法在某些版本上可以奏效，在但Android 5.0+版本中，由于Google开始收紧对Android底层权限管理，在趋势上方法getRunningAppProcesses())将会被毙掉。因为已经在一些版本的环境中，此方法返回null。 第二：UsageStatsManager 使用类UsageStatsManager来获取运行的apps列表，但是使用这个类需要添加一个权限PACKAGE_USAGE_STATS，而此权限是系统权限，要使用必须到Settings应用中去针对应用进行授权（我们的app用户肯定不会愿意多次一步）。另外，据称有些OEM厂商已经删除了此项设置，换言之在Settings中找不到授权入口。 因此这个途径也就被毙掉了。 最终方案 经过几天google方案及针对可能的解决方法进行测试，下边的这个感觉比较靠谱。 这是一个开源项目，项目地址点击这里。 在我们的Application中集成并测试了该方法。 源码中添加一个方法，类似于使用getRunningAppProcesses()方法一样： 以下是在三个不同的Android版本进行测试结果： 可以看到，针对这三个版本是可以达到相关初始化代码只执行一次的效果。这样可以缩短启动消耗的时间。 更多版本类型测试大家可以自行进行测试。 时间原因，此方案的代码及解决方法还没有来得及跟踪，有时间在做分析…… 这种方案也有限制： 一些版本的系统应用不包括在内，因为他们具有更高级别的SElinux context； 这种方法也不是getRunningAppProcesses())完全的替代，因为它无法给出集成的pkgList，lru和importance信息； 此库在7.0开发者预览版本上是无法起作用的。 下面的一篇文章就来分析下此方案是如何解决读取进程的——&gt;《Android获取运行进程解决方案分析》]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>多进程</tag>
        <tag>Application</tag>
      </tags>
  </entry>
</search>
